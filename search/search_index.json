{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Axion","text":"<p>Axion is a cutting-edge differentiable physics simulator that bridges the gap between physical simulation and gradient-based optimization. Built on NVIDIA Warp, it provides researchers and engineers with a powerful tool for developing and testing algorithms in robotics, machine learning, and computational physics.</p>"},{"location":"#why-axion","title":"Why Axion?","text":"<p>Modern robotics and machine learning applications require physics simulators that are not only fast and accurate but also differentiable. Axion addresses this need by providing:</p> <ul> <li>\ud83d\ude80 GPU Acceleration - Leverage CUDA for real-time or faster-than-real-time simulation</li> <li>\ud83d\udd04 Differentiable Simulation - Compute gradients through complex physics for optimization</li> <li>\u2699\ufe0f Flexible Architecture - Modular design allows easy extension and customization</li> <li>\ud83d\udcca Rich Data Logging - Comprehensive HDF5-based logging for analysis and debugging</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Getting Started</p> <p>New to Axion? Start here with installation and your first simulation</p> </li> <li> <p> User Guide</p> <p>Learn core concepts and how to use Axion effectively</p> </li> <li> <p> Tutorials</p> <p>Step-by-step guides for common simulation scenarios</p> </li> <li> <p> API Reference</p> <p>Detailed documentation of all classes and functions</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#physics-capabilities","title":"Physics Capabilities","text":"<p>Axion implements state-of-the-art physics simulation techniques:</p> <ul> <li>Rigid Body Dynamics - Fast and stable simulation of articulated and free-floating bodies</li> <li>Contact &amp; Collision - Robust handling with configurable stiffness and damping parameters</li> <li>Friction Models - Accurate Coulomb friction for realistic contact interactions</li> <li>Joint Constraints - Support for revolute joints</li> </ul>"},{"location":"#technical-features","title":"Technical Features","text":"<ul> <li>Differentiable Simulation - Full gradient computation through the simulation pipeline</li> <li>Constraint-Based Physics - Modern constraint solver for accurate dynamics</li> <li>Matrix-Free Solvers - Memory-efficient algorithms for large-scale systems</li> <li>Hydra Configuration - Flexible experiment management and parameter sweeping</li> <li>CUDA Graph Optimization - Minimized kernel launch overhead for maximum GPU utilization</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcda User Guide - Comprehensive guide to using Axion</li> <li>\ud83c\udf93 Tutorials - Learn by example</li> <li>\ud83d\udcd6 API Reference - Detailed API documentation</li> <li>\ud83d\udc1b Issue Tracker - Report bugs or request features</li> <li>\ud83d\udce7 Contact - Reach out directly</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community! Whether it's bug fixes, new features, or documentation improvements, please check our Contributing Guide to get started.</p>"},{"location":"#license","title":"License","text":"<p>Axion is open-source software licensed under the MIT License. See the LICENSE file for details.</p> <p>Ready to start simulating?</p> Get Started \u2192"},{"location":"advanced/differentiable/","title":"Differentiable Physics","text":"<p>TODO: Differentiable physics guide</p>"},{"location":"advanced/gpu/","title":"GPU Optimization","text":"<p>TODO: GPU optimization guide</p>"},{"location":"advanced/performance/","title":"Performance Tuning","text":"<p>TODO: Performance tuning guide</p>"},{"location":"developer/architecture/","title":"Architecture Overview","text":"<p>TODO: Architecture documentation</p>"},{"location":"developer/contributing/","title":"Contributing Guide","text":"<p>TODO: Contributing guidelines</p>"},{"location":"developer/testing/","title":"Testing Guide","text":"<p>TODO: Testing documentation</p>"},{"location":"getting-started/configuration/","title":"Configuration System","text":"<p>Axion's examples use the Hydra library to manage simulation parameters. This allows for easy experimentation and configuration changes directly from the command line.</p> <p>This Configuration is for the Examples</p> <p>The Hydra configuration files discussed here are located within the <code>axion/examples/conf</code> directory. They are designed to make running the pre-built examples easy and flexible.</p> <p>You are not required to use Hydra in your own projects. You can instantiate Axion's configuration classes directly in your Python code. This guide explains how the examples are set up so you can understand them and optionally adapt the pattern for your own use.</p>"},{"location":"getting-started/configuration/#how-the-examples-use-hydra","title":"How the Examples Use Hydra","text":"<p>The core idea is to separate configuration from code. Instead of hardcoding values like simulation duration or solver iterations, these values are defined in <code>.yaml</code> files.</p>"},{"location":"getting-started/configuration/#the-configuration-directory-structure","title":"The Configuration Directory Structure","text":"<p>All configuration files for the examples live in <code>src/axion/examples/conf/</code>:</p> <pre><code>conf/\n\u251c\u2500\u2500 config.yaml              # Main configuration entry point\n\u251c\u2500\u2500 engine/                  # Physics engine settings (e.g., base.yaml)\n\u251c\u2500\u2500 simulation/              # Time parameters (e.g., base.yaml)\n\u251c\u2500\u2500 rendering/               # USD output settings (e.g., 30_fps.yaml, headless.yaml)\n\u251c\u2500\u2500 execution/               # Performance settings (e.g., cuda_graph.yaml)\n\u2514\u2500\u2500 profiling/               # Debugging/timing settings (e.g., disabled.yaml)\n</code></pre> <p>The main <code>config.yaml</code> file defines the default configuration by composing files from each subdirectory, which Hydra calls Configuration Groups.</p> conf/config.yaml<pre><code>defaults:\n  - simulation: base\n  - rendering: 30_fps \n  - execution: cuda_graph\n  - profiling: disabled\n  - engine: base\n  - _self_\n\nproject_name: ${hydra:job.name}\n</code></pre> <p>This tells Hydra: \"By default, use <code>base.yaml</code> from the <code>simulation/</code> group, <code>30_fps.yaml</code> from the <code>rendering/</code> group, and so on.\"</p>"},{"location":"getting-started/configuration/#command-line-usage-for-examples","title":"Command-Line Usage for Examples","text":"<p>This system makes it easy to modify any parameter without changing the source code.</p>"},{"location":"getting-started/configuration/#viewing-the-configuration","title":"Viewing the Configuration","text":"<p>To see all available parameters and their default values, run any example with the <code>--help</code> (or <code>-h</code>) flag:</p> <pre><code>uv run ball_bounce_example --help\n</code></pre>"},{"location":"getting-started/configuration/#overriding-parameters","title":"Overriding Parameters","text":"<p>You can override any parameter from the command line using the <code>key=value</code> syntax. For nested parameters, use a dot (<code>.</code>) path.</p> Overriding Specific Parameters<pre><code># Run for 10 seconds instead of the default 4.0s\nuv run ball_bounce_example simulation.duration_seconds=10.0\n\n# Increase physics solver accuracy\nuv run ball_bounce_example engine.newton_iters=16\n</code></pre>"},{"location":"getting-started/configuration/#switching-configuration-groups","title":"Switching Configuration Groups","text":"<p>A more powerful feature is swapping out entire groups of settings.</p> Switching Groups<pre><code># Run in \"headless\" mode (disables USD rendering, useful for training)\nuv run ball_bounce_example rendering=headless\n\n# Use a different set of physics engine parameters\nuv run helhest_example engine=helhest\n</code></pre>"},{"location":"getting-started/configuration/#how-its-implemented","title":"How It's Implemented","text":"<p>Let's look at <code>ball_bounce_example.py</code> to see how code and configuration are connected.</p> ball_bounce_example.py<pre><code>from importlib.resources import files\n\nimport hydra\nimport warp as wp\nfrom axion import (\n    AbstractSimulator, EngineConfig, ExecutionConfig, \n    ProfilingConfig, RenderingConfig, SimulationConfig\n)\nfrom omegaconf import DictConfig\n\n# (1) Define the path to the example configuration files\nCONFIG_PATH = files(\"axion\").joinpath(\"examples\").joinpath(\"conf\")\n\nclass Simulator(AbstractSimulator):\n    # ... (build_model implementation)\n    ...\n\n# (2) Decorate the main function to enable Hydra\n@hydra.main(config_path=str(CONFIG_PATH), config_name=\"config\", version_base=None)\ndef ball_bounce_example(cfg: DictConfig): # (3)\n\n    # (4) Instantiate Python objects from the configuration\n    sim_config: SimulationConfig = hydra.utils.instantiate(cfg.simulation)\n    render_config: RenderingConfig = hydra.utils.instantiate(cfg.rendering)\n    exec_config: ExecutionConfig = hydra.utils.instantiate(cfg.execution)\n    profile_config: ProfilingConfig = hydra.utils.instantiate(cfg.profiling)\n    engine_config: EngineConfig = hydra.utils.instantiate(cfg.engine)\n\n    simulator = Simulator(\n        sim_config=sim_config,\n        render_config=render_config,\n        exec_config=exec_config,\n        profile_config=profile_config,\n        engine_config=engine_config,\n    )\n\n    simulator.run()\n\nif __name__ == \"__main__\":\n    ball_bounce_example()\n</code></pre> <ol> <li>Locating Config Files: The script uses <code>importlib.resources</code> to find the absolute path to the <code>conf</code> directory inside the installed <code>axion</code> package.</li> <li>The <code>@hydra.main</code> Decorator: This is the magic that hooks your function into Hydra. It tells Hydra where to find the configuration files (<code>config_path</code> and <code>config_name</code>).</li> <li>Receiving the Configuration: Hydra parses the YAML files and command-line overrides, then passes the final, merged configuration into your function as a special dictionary-like object called a <code>DictConfig</code>.</li> <li>Instantiating Objects: The <code>_target_</code> key in the YAML files (e.g., <code>_target_: axion.SimulationConfig</code>) tells Hydra which Python class to create. The <code>hydra.utils.instantiate()</code> function reads this key and uses the rest of the config values as constructor arguments to create the actual <code>SimulationConfig</code>, <code>EngineConfig</code>, etc. objects.</li> </ol>"},{"location":"getting-started/configuration/#using-configuration-in-your-own-project","title":"Using Configuration in Your Own Project","text":"<p>You have two primary options for managing configuration in your own Axion-based project.</p> Option 1: Without HydraOption 2: With Hydra <p>You don't need Hydra at all. You can simply import the configuration dataclasses and instantiate them yourself. This is the most straightforward approach for simple projects.</p> <pre><code>from axion import (\n    Simulator, SimulationConfig, EngineConfig, RenderingConfig, \n    ExecutionConfig, ProfilingConfig\n)\n\n# Manually create the configuration objects\nsim_config = SimulationConfig(\n    duration_seconds=3.0,\n    target_timestep_seconds=1e-3,\n)\n\nrender_config = RenderingConfig(\n    enable=True,\n    fps=30,\n    scaling=100.0,\n    usd_file=\"sim.usd\",\n)\n\nexec_config = ExecutionConfig(\n    use_cuda_graph=True,\n    headless_steps_per_segment=10,\n)\n\nprofile_config = ProfilingConfig(\n    enable_timing=False,\n    enable_hdf5_logging=False,\n    hdf5_log_file=\"simulation.h5\",\n)\n\nengine_config = EngineConfig(\n    newton_iters=8,\n    linear_iters=4,\n    joint_stabilization_factor=0.01,\n    contact_stabilization_factor=0.1,\n    contact_compliance=1e-4,\n    friction_compliance=1e-6,\n    contact_fb_alpha=0.25,\n    contact_fb_beta=0.25,\n    friction_fb_alpha=0.25,\n    friction_fb_beta=0.25,\n    linesearch_steps=2,\n    matrixfree_representation=True,\n)\n\nsimulator = MySimulator(\n    sim_config=sim_config,\n    render_config=render_config,\n    exec_config=exec_config,\n    profile_config=profile_config,\n    engine_config=engine_config,\n)\n\nmy_sim.run()\n</code></pre> <p>If you like the flexibility of the examples, you can adopt the same pattern.</p> <ol> <li>Copy the <code>conf</code> directory from <code>src/axion/examples/conf</code> into your own project's root.</li> <li>Create your main script and use the <code>@hydra.main</code> decorator, pointing it to your new <code>conf</code> directory.</li> </ol> <pre><code>import hydra\nfrom omegaconf import DictConfig\nfrom axion import ...\n\n@hydra.main(config_path=\"str(CONFIG_PATH)\", config_name=\"config\", version_base=None)\ndef my_main_function(cfg: DictConfig):\n    # The rest of the logic is the same as the examples...\n    sim_config = hydra.utils.instantiate(cfg.simulation)\n    engine_config = hydra.utils.instantiate(cfg.engine)\n    # ...\n</code></pre> <p>This gives you a powerful, battle-tested configuration system for your project with minimal setup.</p>"},{"location":"getting-started/first-simulation/","title":"Your First Simulation","text":"<p>This tutorial will guide you through creating a custom physics simulation with Axion.</p>"},{"location":"getting-started/first-simulation/#basic-structure","title":"Basic Structure","text":"<p>Every Axion simulation follows the same pattern:</p> <p>The Three Core Steps</p> <ol> <li>Inherit from <code>AbstractSimulator</code> - This base class handles the simulation loop, USD export, and configuration.</li> <li>Override <code>build_model()</code> - This is where you define your physics scene (bodies, joints, constraints).</li> <li>Configure and run - You set physics parameters and execute the simulation from the main entry point.</li> </ol> <p>The simplest possible simulator looks like this:</p> <pre><code>from axion import AbstractSimulator\nimport warp as wp\n\nclass MySimulator(AbstractSimulator):\n    def build_model(self) -&gt; wp.sim.Model:\n        # Build your physics model here\n        pass\n</code></pre>"},{"location":"getting-started/first-simulation/#step-1-create-a-falling-rod","title":"Step 1: Create a Falling Rod","text":"<p>Let's begin by creating a simple simulation of a single rod falling under gravity. This will introduce the core concepts of rigid bodies and shapes.</p> <pre><code>import warp as wp\nfrom axion import AbstractSimulator\nfrom axion import EngineConfig\nfrom axion import ExecutionConfig\nfrom axion import ProfilingConfig\nfrom axion import RenderingConfig\nfrom axion import SimulationConfig\n\n\nclass Simulator(AbstractSimulator):\n    def __init__(\n        self,\n        sim_config: SimulationConfig,\n        render_config: RenderingConfig,\n        exec_config: ExecutionConfig,\n        profile_config: ProfilingConfig,\n        engine_config: EngineConfig,\n    ):\n        super().__init__(sim_config, render_config, exec_config, profile_config, engine_config)\n\n    def build_model(self) -&gt; wp.sim.Model:\n        # Create model builder with Z-axis up (gravity points down in -Z)\n        builder = wp.sim.ModelBuilder(up_vector=wp.vec3(0, 0, 1))\n\n        # Define initial rotation: 15 degrees tilt around X-axis\n        # This makes the rod fall instead of standing perfectly upright\n        angle = 0.2618  # radians (approx. 15 degrees)\n        rot_a_quat = wp.quat_from_axis_angle(wp.vec3(1.0, 0.0, 0.0), angle)\n\n        # (1) Create a rigid body \"rod A\" at position (0, 0, 3) meters\n        # The rod starts 3 meters above ground with a slight tilt\n        rod_a = builder.add_body(\n            origin=wp.transform((0, 0, 3), rot_a_quat),\n            name=\"rod A\"\n        )\n\n        # (2) Attach a box shape to the body (this defines its collision geometry)\n        builder.add_shape_box(\n            body=rod_a,\n            hx=0.2,  # half-width: 0.4m total width\n            hy=0.2,  # half-depth: 0.4m total depth  \n            hz=1.0,  # half-height: 2.0m total height (tall rod)\n            density=1000.0,      # kg/m\u00b3 (like water)\n            mu=0.8,              # friction coefficient (fairly grippy)\n            restitution=0.3,     # bounce factor (0=no bounce, 1=perfect bounce)\n        )\n\n        # (3) This creates an infinite horizontal surface at Z=0\n        builder.set_ground_plane(mu=0.8, restitution=0.3)\n\n        # Finalize the model (required to prepare for simulation)\n        return builder.finalize()\n\nif __name__ == \"__main__\":\n    # Create simulator instance with configuration\n    sim = Simulator(\n        sim_config=SimulationConfig(duration_seconds=5.0),  # Run for 5 seconds\n        render_config=RenderingConfig(),                    # Default rendering settings\n        exec_config=ExecutionConfig(),                      # Default execution (GPU if available)\n        profile_config=ProfilingConfig(),                   # No profiling by default\n        engine_config=EngineConfig(),                       # Default physics settings\n    )\n    sim.run()  # Execute the simulation and generate USD file\n</code></pre> <ol> <li>Create a Rigid Body: The <code>origin</code> transform sets the body's initial state. It combines a position (<code>(0, 0, 3)</code>) with a rotation (<code>rot_a_quat</code>) to place the body in the world. A body itself has no physical presence; it's just a point in space.</li> <li>Define its Shape: We give the body physical form by attaching a <code>shape</code>. <code>add_shape_box</code> creates a box collider. The <code>h</code> prefix in <code>hx</code>, <code>hy</code>, <code>hz</code> stands for half-extents. So, a <code>hz</code> of <code>1.0</code> creates a rod that is 2.0 meters tall. The shape also defines the physical material properties.</li> <li>Add a Ground Plane: This is a convenient helper to create an infinite, static collision surface at <code>Z=0</code> so objects have something to collide with.</li> </ol> <p>Result</p> <p>When you run <code>uv run python first_simulation.py</code>:</p> <ol> <li>Initialization: The rod spawns 3 meters above the ground with a 15\u00b0 tilt.</li> <li>Gravity: The rod falls under gravity (9.81 m/s\u00b2 downward).</li> <li>Impact: When it hits the ground plane, the physics engine computes contact forces.</li> <li>Friction &amp; Bounce: The rod tumbles and slides to a rest, governed by the <code>mu</code> and <code>restitution</code> values. A USD file is saved with the animation.</li> </ol>"},{"location":"getting-started/first-simulation/#step-2-add-multiple-bodies","title":"Step 2: Add Multiple Bodies","text":"<p>Now let's add a second rod. This demonstrates how the physics engine automatically handles body-body collisions in addition to body-ground collisions.</p> <pre><code># ... (imports and class definition are the same) ...\n\n    def build_model(self) -&gt; wp.sim.Model:\n        builder = wp.sim.ModelBuilder(up_vector=wp.vec3(0, 0, 1))\n\n        # Create two rods with opposite tilts - they'll fall toward each other\n        angle = 0.2618  # 15 degrees in radians\n\n        # Rod A: tilted forward (+15\u00b0)\n        rot_a_quat = wp.quat_from_axis_angle(wp.vec3(1.0, 0.0, 0.0), angle)\n        rod_a = builder.add_body(\n            origin=wp.transform((0, 0, 3), rot_a_quat), \n            name=\"rod A\"\n        )\n        builder.add_shape_box(\n            body=rod_a,\n            hx=0.2, hy=0.2, hz=1.0,  # Same dimensions as before\n            density=1000.0,\n            mu=0.8, restitution=0.3,\n        )\n\n        # Rod B: tilted backward (-15\u00b0) and offset 1m in Y direction\n        rot_b_quat = wp.quat_from_axis_angle(wp.vec3(1.0, 0.0, 0.0), -angle) # (1)\n        rod_b = builder.add_body(\n            origin=wp.transform((0, 1, 3), rot_b_quat),  # (2)\n            name=\"rod B\"\n        )\n        builder.add_shape_box(\n            body=rod_b,\n            hx=0.2, hy=0.2, hz=1.0,\n            density=1000.0,  # Same material properties\n            mu=0.8, restitution=0.3,\n        )\n\n        # Add ground plane for both rods to land on\n        builder.set_ground_plane(mu=0.8, restitution=0.3)\n\n        return builder.finalize()\n\n# ... (if __name__ == \"__main__\" block is the same) ...\n</code></pre> <ol> <li>Opposite Tilt: We create a new rotation for Rod B using <code>-angle</code>. This makes it tilt in the opposite direction from Rod A, causing them to fall towards each other.</li> <li>Different Position: We change the <code>x, y, z</code> position in the <code>transform</code> to <code>(0, 1, 3)</code>. This spawns Rod B one meter away from Rod A along the Y-axis.</li> </ol> <p>What's New in Step 2?</p> <ul> <li>Multiple Bodies: We now have two dynamic bodies, <code>rod A</code> and <code>rod B</code>.</li> <li>Body-Body Collision: The physics engine will now solve for contacts between the two rods in addition to contacts with the ground.</li> <li>Different Initial Conditions: By giving the rods opposite tilts and slightly different starting positions, you can create more complex and interesting interactions.</li> </ul>"},{"location":"getting-started/first-simulation/#step-3-add-joints","title":"Step 3: Add Joints","text":"<p>Constraints are used to connect bodies and restrict their motion. Here, we'll connect the two rods with a revolute joint to create a hinged mechanism.</p> <pre><code># ... (imports and class definition are the same) ...\n\n    def build_model(self) -&gt; wp.sim.Model:\n        # Create model builder with Z-axis up\n        builder = wp.sim.ModelBuilder(up_vector=wp.vec3(0, 0, 1))\n\n        angle = 0.2618\n        rot_a_quat = wp.quat_from_axis_angle(wp.vec3(1.0, 0.0, 0.0), angle)\n\n        # Add rod A with initial rotation\n        rod_a = builder.add_body(origin=wp.transform((0, 0, 3), rot_a_quat), name=\"rod A\")\n        builder.add_shape_box(\n            body=rod_a,\n            hx=0.2, hy=0.2, hz=1.0,\n            density=1000.0, mu=0.8, restitution=0.3,\n        )\n\n        rot_b_quat = wp.quat_from_axis_angle(wp.vec3(1.0, 0.0, 0.0), -angle)\n\n        # Add rod B with initial rotation\n        rod_b = builder.add_body(origin=wp.transform((0, 1, 3), rot_b_quat), name=\"rod B\")\n        builder.add_shape_box(\n            body=rod_b,\n            hx=0.2, hy=0.2, hz=1.0,\n            density=1000.0, mu=0.8, restitution=0.3,\n        )\n\n        # Add revolute joint connecting the two rods\n        # This creates a hinge that allows rotation around the X-axis\n        builder.add_joint_revolute( # (1)\n            parent=rod_a,                                    # First rod acts as parent\n            child=rod_b,                                     # Second rod is the child\n            axis=wp.vec3(1.0, 0.0, 0.0),                     # Rotation axis (X-axis)\n            # Connection points are computed to be at the bottom corners of each rod\n            # These coordinates account for the initial rotations and positions\n            parent_xform=wp.transform( # (2)\n                wp.vec3(0.0, 0.2329623, -1.06242221),\n                wp.quat_identity()\n            ),\n            child_xform=wp.transform( # (3)\n                wp.vec3(0.0, -0.2329623, -1.06242221),\n                wp.quat_identity()\n            ),\n        )\n\n        builder.set_ground_plane(mu=0.8, restitution=0.3)\n        return builder.finalize()\n\n# ... (if __name__ == \"__main__\" block is the same) ...\n</code></pre>"},{"location":"getting-started/first-simulation/#understanding-joints","title":"Understanding Joints","text":"<ol> <li><code>add_joint_revolute</code>: This function creates a hinge joint. It constrains the motion between a <code>parent</code> and <code>child</code> body, forcing them to pivot around a common point along a specified <code>axis</code>.</li> <li><code>parent_xform</code>: This defines the joint's anchor point in the local coordinate system of the parent body (<code>rod_a</code>). The joint frame is attached to <code>rod_a</code> at this local transform.</li> <li><code>child_xform</code>: This defines the joint's anchor point in the local coordinate system of the child body (<code>rod_b</code>). The physics engine will ensure these two local frames are always coincident, creating the joint.</li> </ol>"},{"location":"getting-started/first-simulation/#understanding-the-physics-parameters","title":"Understanding the Physics Parameters","text":"<p>Let's break down the key parameters you've been using.</p>"},{"location":"getting-started/first-simulation/#material-properties","title":"Material Properties","text":"<p>These are set on <code>add_shape_*</code> calls and define how a body reacts to contact.</p> Parameter Type Description <code>density</code> <code>float</code> Mass per unit volume (kg/m\u00b3). In combination with the shape's volume, this determines the final mass and inertia of the body. <code>mu</code> <code>float</code> Coulomb friction coefficient. <code>0.0</code> is frictionless (like ice), while <code>1.0</code> is very high friction. <code>restitution</code> <code>float</code> Coefficient of restitution, or \"bounciness\". <code>0.0</code> means no bounce at all, while <code>1.0</code> would be a perfectly elastic bounce with no energy loss."},{"location":"getting-started/first-simulation/#transform-and-rotation","title":"Transform and Rotation","text":"<p>A transform defines an object's position and orientation in space.</p> <pre><code># A transform combines a position vector and a rotation quaternion\nwp.transform(wp.vec3(x, y, z), quaternion)\n\n# A quaternion is a way to represent 3D rotation.\n# The easiest way to create one is from an axis and an angle.\nwp.quat_from_axis_angle(axis_vector, angle_in_radians)\n\n# Common Axes:\n# X-axis: wp.vec3(1, 0, 0)\n# Y-axis: wp.vec3(0, 1, 0)\n# Z-axis: wp.vec3(0, 0, 1)  (This is our 'up' vector)\n</code></pre>"},{"location":"getting-started/first-simulation/#configuration-options","title":"Configuration Options","text":"<p>The <code>__main__</code> block in the script passes several configuration objects to the simulator. You can customize them to change the simulation's behavior.</p> SimulationConfigEngineConfigRenderingConfigExecutionConfigProfilingConfig <pre><code>@dataclass\nclass SimulationConfig:\n    \"\"\"Parameters defining the simulation's timeline.\"\"\"\n\n    duration_seconds: float = 3.0\n    target_timestep_seconds: float = 1e-3\n</code></pre> <pre><code>@dataclass(frozen=True)\nclass EngineConfig:\n    \"\"\"\n    Configuration parameters for the AxionEngine solver.\n\n    This object centralizes all tunable parameters for the physics simulation,\n    including solver iterations, stabilization factors, and compliance values.\n    Making it a frozen dataclass ensures that configuration is immutable\n    during a simulation run.\n    \"\"\"\n\n    newton_iters: int = 8\n    linear_iters: int = 4\n\n    joint_stabilization_factor: float = 0.01\n    contact_stabilization_factor: float = 0.1\n    contact_compliance: float = 1e-4\n    friction_compliance: float = 1e-6\n\n    contact_fb_alpha: float = 0.25\n    contact_fb_beta: float = 0.25\n    friction_fb_alpha: float = 0.25\n    friction_fb_beta: float = 0.25\n\n    linesearch_steps: int = 2\n\n    matrixfree_representation: bool = True\n</code></pre> <pre><code>@dataclass\nclass RenderingConfig:\n    \"\"\"Parameters for rendering the simulation to a USD file.\"\"\"\n\n    enable: bool = True\n    fps: int = 30\n    scaling: float = 100.0\n    usd_file: str = \"sim.usd\"\n</code></pre> <pre><code>@dataclass\nclass ExecutionConfig:\n    \"\"\"Parameters controlling the performance and execution strategy.\"\"\"\n\n    use_cuda_graph: bool = True\n    headless_steps_per_segment: int = 10\n</code></pre> <pre><code>@dataclass\nclass ProfilingConfig:\n    \"\"\"Parameters for debugging, timing, and logging.\"\"\"\n\n    enable_timing: bool = False\n\n    # Enables HDF5 logging (disables CUDA graph optimization).\n    enable_hdf5_logging: bool = False\n    hdf5_log_file: str = \"simulation.log\"\n</code></pre>"},{"location":"getting-started/first-simulation/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the User Guide to understand core physics concepts in more depth.</li> <li>Learn about other constraints like prismatic (slider) or ball joints.</li> <li>See all available configuration options for fine-tuning your simulation.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will walk you through installing Axion and its dependencies. The recommended method uses <code>uv</code>, a modern Python packaging tool that simplifies the entire process.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Axion, please ensure your system meets the following requirements.</p>"},{"location":"getting-started/installation/#system-and-software","title":"System and Software","text":"<ul> <li>Operating System: Linux (Ubuntu 20.04+ recommended) or macOS.</li> <li>Python: Version 3.12 or higher.</li> <li>CUDA (Optional): Version 11.8 or higher is strongly recommended for significant performance gains on NVIDIA GPUs.</li> </ul> <p>Windows Users: Use WSL2</p> <p>While Axion can run on various systems, many core scientific computing libraries (including some used by Axion) have the best support and performance on Linux. We strongly recommend using the Windows Subsystem for Linux (WSL2) to create a Linux environment on your Windows machine.</p>"},{"location":"getting-started/installation/#environment-checks","title":"Environment Checks","text":"<ol> <li> <p>Verify your Python version:</p> <pre><code>python --version\n# Expected output: Python 3.12.x or higher\n</code></pre> </li> <li> <p>Verify CUDA installation (if you have an NVIDIA GPU):</p> <pre><code>nvidia-smi\n# This command should output details about your GPU and the installed driver.\n</code></pre> </li> </ol>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":"<p>We use uv, an extremely fast Python package installer and resolver. It replaces the need for <code>pip</code> and <code>venv</code> with a single, unified toolchain.</p>"},{"location":"getting-started/installation/#step-1-install-uv","title":"Step 1: Install <code>uv</code>","text":"<p>If you don't have <code>uv</code> installed, choose the appropriate method for your OS. It's a standalone tool that can be installed quickly.</p> Linux / macOSWindows (PowerShell) <pre><code># Use the official installer (recommended)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code># Use the official PowerShell installer\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre>"},{"location":"getting-started/installation/#step-2-clone-the-axion-repository","title":"Step 2: Clone the Axion Repository","text":"<p>Get the source code from GitHub:</p> <pre><code>git clone https://github.com/aleskucera/axion.git\ncd axion\n</code></pre>"},{"location":"getting-started/installation/#step-3-create-environment-and-install-dependencies","title":"Step 3: Create Environment and Install Dependencies","text":"<p>This is where <code>uv</code> shines. A single command handles everything.</p> <pre><code>uv sync\n</code></pre> <p>The <code>uv sync</code> command is a powerful all-in-one tool. It reads the <code>pyproject.toml</code> file and performs two actions automatically:</p> <ul> <li>Creates a virtual environment in the <code>.venv</code> directory.</li> <li>Installs all required dependencies into that environment, ensuring a consistent and isolated setup.</li> </ul> <p>What is <code>uv sync</code> doing?</p> <p>Unlike traditional <code>pip install -r requirements.txt</code>, <code>uv sync</code> ensures that the environment is an exact reflection of the project's locked dependencies. It will add missing packages and remove ones that are not specified, guaranteeing a reproducible environment.</p>"},{"location":"getting-started/installation/#step-4-verify-your-installation","title":"Step 4: Verify Your Installation","text":"<p>To confirm everything is working, run one of the included examples.</p> <pre><code>uv run ball_bounce_example\n</code></pre> <p>The <code>uv run</code> command executes a command inside the virtual environment managed by <code>uv</code>. This saves you from having to manually run <code>source .venv/bin/activate</code> every time. The command <code>ball_bounce_example</code> is a shortcut defined in <code>pyproject.toml</code>.</p>"},{"location":"getting-started/installation/#dependency-overview","title":"Dependency Overview","text":"<p>Axion relies on a set of high-performance libraries for physics, computation, and configuration. <code>uv sync</code> installs all of these for you.</p> Package Purpose <code>warp-lang</code> The core physics and graphics engine from NVIDIA that enables differentiable simulation. <code>torch</code> Provides the fundamental tensor library and autograd capabilities that make differentiation possible. <code>hydra-core</code> A powerful system for managing complex configurations in your simulations. <code>h5py</code> Used for efficient I/O, allowing you to log and save large datasets in the HDF5 format. <code>trimesh</code> A utility for loading and processing 3D mesh files for collision geometries. <code>scipy</code> Provides a broad set of scientific computing tools used across the library. <code>nvtx</code> Allows for deep performance profiling of code running on NVIDIA GPUs. <p>Installation Complete!</p> <p>You are now ready to build and run your first simulation with Axion.</p> <ul> <li>Continue to the First Simulation Tutorial to build a simple physics scene.</li> <li>Explore the User Guide for in-depth explanations of advanced features.</li> <li>If you encounter any issues, please check the GitHub Issues page.</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with Axion in minutes. This guide assumes you have already installed Axion using <code>uv</code>.</p>"},{"location":"getting-started/quickstart/#running-your-first-simulation","title":"Running Your First Simulation","text":"<p>Axion comes with several pre-built examples. Let's run the simplest one.</p> <pre><code>uv run ball_bounce_example\n</code></pre> <p>This command will:</p> <ol> <li>Execute the physics simulation for a ball bouncing on a ground plane.</li> <li>Generate a <code>ball_bounce_example.usd</code> file in your directory containing the full motion history.</li> </ol> <p>Viewing USD Files</p> <p>Universal Scene Description (<code>.usd</code>) is a 3D scene format developed by Pixar. You can view the output files using any USD-compatible viewer, such as Blender or Apple's Reality Converter.</p>"},{"location":"getting-started/quickstart/#exploring-the-examples","title":"Exploring the Examples","text":"<p>You can run several other examples using the same <code>uv run</code> command. Each demonstrates different features of the Axion physics engine.</p> Command Description <code>uv run ball_bounce_example</code> A simple ball bouncing, demonstrating basic rigid body dynamics and collision. <code>uv run collision_primitives_example</code> Multiple primitive shapes (spheres, boxes, capsules) interacting with each other. <code>uv run helhest_example</code> A simulation of an articulated quadruped robot, demonstrating joints, actuators, and more complex dynamics."},{"location":"getting-started/quickstart/#configuration-with-hydra","title":"Configuration with Hydra","text":"<p>All examples are configured using a powerful library called Hydra. Hydra allows you to easily override any part of the simulation's configuration directly from the command line, without ever touching the code.</p> <p>The configuration files for the examples are located in <code>src/axion/examples/conf/</code>.</p>"},{"location":"getting-started/quickstart/#viewing-all-configuration-options","title":"Viewing All Configuration Options","text":"<p>To see every available parameter, its default value, and the available configuration groups, run any example with the <code>-h</code> or <code>--help</code> flag. hydra.cc</p> <pre><code>uv run ball_bounce_example -h\n</code></pre> <p>This will print a detailed help message showing the entire default configuration tree.</p>"},{"location":"getting-started/quickstart/#overriding-specific-parameters","title":"Overriding Specific Parameters","text":"<p>You can change any setting using the <code>key=value</code> syntax. For nested parameters, use a dot (<code>.</code>) path.</p> Command-Line Overrides<pre><code># Change the simulation duration from 4.0s to 10.0s\nuv run ball_bounce_example simulation.duration_seconds=10.0\n\n# Increase the physics solver accuracy by using more iterations\nuv run ball_bounce_example engine.newton_iters=20\n\n# Run a simulation for 2 seconds and save the output to a different file\nuv run ball_bounce_example simulation.duration_seconds=2.0 rendering.usd_file=my_test.usd\n</code></pre>"},{"location":"getting-started/quickstart/#using-configuration-groups","title":"Using Configuration Groups","text":"<p>The help output also shows <code>Configuration groups</code>. These are pre-defined bundles of settings that let you swap out entire sections of the configuration with a single command.</p> <p>For example, the <code>rendering</code> group has two options: <code>30_fps</code> (the default) and <code>headless</code>.</p> Using Configuration Groups<pre><code># Run the simulation without rendering to a USD file (useful for headless servers)\nuv run ball_bounce_example rendering=headless\n</code></pre> <p>By specifying <code>rendering=headless</code>, you are selecting the <code>headless.yaml</code> configuration file from the <code>src/axion/examples/conf/rendering/</code> directory. This single command is a shortcut for setting <code>rendering.enable=false</code>.</p> <p>Combining Overrides</p> <p>You can combine configuration groups and specific overrides in a single command. The most specific override (the <code>key=value</code> pair) always wins.</p> <pre><code># Use the 'helhest' simulation settings but override the duration\nuv run helhest_example simulation=helhest simulation.duration_seconds=5.0\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>You now have the basics of running and configuring Axion simulations.</p> <ul> <li>Create Your First Simulation to learn how to build a scene from scratch.</li> <li>Dive into the User Guide to understand the core physics concepts behind Axion.</li> <li>Explore the Configuration System Guide for a deeper look into how Hydra is used in Axion.</li> </ul>"},{"location":"implementation/engine/","title":"Engine API","text":"<p>The <code>AxionEngine</code> is the low-level physics solver at the core of the simulation. Most users will interact with it indirectly through the <code>AbstractSimulator</code> class, but understanding its API and configuration is key to tuning performance and achieving specific physical behaviors.</p> <p>The engine implements a Non-Smooth Newton Method to solve the entire physics state\u2014including dynamics, contacts, and joints\u2014as a single, unified problem at each time step. This monolithic approach provides exceptional stability, especially for complex, highly-constrained systems like articulated robots.</p>"},{"location":"implementation/engine/#the-axionengine-class","title":"The <code>AxionEngine</code> Class","text":"<p>This is the main backend simulation class. It takes a static <code>warp.sim.Model</code>, configuration parameters, and an optional logger. The engine creates and manages all necessary GPU data structures and executes the simulation loop. The data are then outputted via the <code>state_out</code> argument in the <code>simulate</code> and <code>simulate_scipy</code> methods.</p> <pre><code>from axion.core import AxionEngine\n\nclass AxionEngine(Integrator):\n    def __init__(\n        self,\n        model: Model,\n        config: Optional[EngineConfig],\n        logger: Optional[HDF5Logger | NullLogger],\n    )\n</code></pre> Parameter Type Description <code>model</code> <code>warp.sim.Model</code> The physics model created by a <code>ModelBuilder</code>, containing all bodies, shapes, and joints. <code>config</code> <code>EngineConfig</code> A configuration dataclass that holds all tunable solver parameters. <code>logger</code> <code>HDF5Logger</code> or <code>NullLogger</code> An optional logger for recording detailed simulation data to a file."},{"location":"implementation/engine/#key-methods","title":"Key Methods","text":""},{"location":"implementation/engine/#simulate","title":"<code>simulate()</code>","text":"<p>The primary method for running the physics simulation for a single time step.</p> <pre><code>def simulate(\n    model: Model,\n    state_in: State,\n    state_out: State, \n    dt: float,\n    control: Optional[Control] = None,\n) -&gt; List[Dict[str, Event]]\n</code></pre> <p>This method executes the core solver loop on the GPU, applying control inputs and calculating the resulting state after <code>dt</code> seconds. The method returns a list of events used for logging and analysis. The main output of the method is the updated <code>state_out</code> object, which contains the new positions and velocities of all bodies. More details on the solving process are provided in the next section.</p>"},{"location":"implementation/engine/#simulate_scipy","title":"<code>simulate_scipy()</code>","text":"<p>An alternative solver implementation that uses SciPy's numerical root-finding algorithms.</p> <pre><code>def simulate_scipy(\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    control: Optional[Control] = None,\n) -&gt; List[Dict[str, Event]]\n</code></pre> <p>For Debugging and Validation Only</p> <p>The <code>simulate_scipy</code> method runs on the CPU and is significantly slower than the native GPU-based <code>simulate</code> method. It is provided as a tool for validating the physics results against a well-established numerical library, not for performance-critical applications.</p>"},{"location":"implementation/engine/#the-solving-process","title":"The Solving Process","text":"<p>The <code>AxionEngine.simulate</code> method orchestrates a multi-stage process for each time step, executed entirely either on the GPU (for <code>simulate</code>) or CPU (for <code>simulate_scipy</code>). Below is a high-level overview of the key stages in the simulation loop.</p>"},{"location":"implementation/engine/#1-apply-controls-integrate","title":"1. Apply Controls &amp; Integrate","text":"<pre><code>def apply_control(\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    control: Control | None = None,\n)\n</code></pre> <p>External forces and torques from the <code>warp.sim.Control</code> object are applied to the bodies in the <code>state_in.body_f</code> argument via the <code>apply_control</code> method.</p> <pre><code>def integrate_bodies(\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    angular_damping: float = 0.0,\n)\n</code></pre> <p>An initial \"guess\" for the next state's velocity (<code>state_out.body_qd</code>) and position (<code>state_out.body_q</code>) is calculated using semi-implicit Euler integration in the <code>warp.sim.Integrator.integrate_bodies</code> function.</p>"},{"location":"implementation/engine/#2-the-non-smooth-newton-loop","title":"2. The Non-Smooth Newton Loop","text":"<p>The engine then enters the main Newton iteration loop for <code>EngineConfig.newton_iters</code> iterations. Each iteration aims to refine the solution.</p>"},{"location":"implementation/engine/#a-linearize","title":"a) Linearize","text":"<p><pre><code>def compute_linear_system(\n    model: Model,\n    data: EngineArrays,\n    config: EngineConfig,\n    dims: EngineDimensions,\n    dt: float\n)\n</code></pre> The engine evaluates all constraints and linearizes them, forming a large linear system of equations as described in the theory section. Since we know the structure of the system, we can construct the system efficiently without explicitly forming large matrices, which would consist of many zero elements. This is done in <code>compute_linear_system</code> method, which updates the <code>self.data</code> attribute, resulting in the following simplified matrix-free representation:</p> <ul> <li>Dynamic Matrix (H) is a block diagonal matrix. It can be represented via one float for mass and 3x3 matrix for inertia per body.</li> <li>Compliance (C) is a diagonal matrix, represented as a vector of its diagonal elements.</li> <li>Jacobian (J) is a matrix representing constraint between two bodies. Each constraint can be represented as two integer indices of the two bodies and two Nx6 matrices, where 6 is DoF of a spatial body and N is the number of constraint equations. Rotational joint constraints are represented by 5 equations, contact constraint by 1 equation, and friction by 2 equations.</li> </ul>"},{"location":"implementation/engine/#b-solve-and-compute-velocities","title":"b) Solve and Compute Velocities","text":"<p><pre><code>def cr_solver(\n    A: LinearOperator,\n    b: wp.array,\n    x: wp.array,\n    iters: int,\n    preconditioner: Optional[LinearOperator] = None,\n    logger: Optional[HDF5Logger | NullLogger] = NullLogger,\n)\n</code></pre> The <code>cr_solver</code> method is the core of the iteration. It solves the linear system and updates the <code>self.data.delta_lambda</code> (the change in constraint impulses) using a Conjugate Residual (CR) iterative solver. This step runs for <code>linear_iters</code>. Since the system is represented in a matrix-free form, the solver uses matrix-free operator to compute required quantities efficiently.</p> <p><pre><code>def compute_delta_body_qd_from_delta_lambda(\n    data: EngineArrays,\n    config: EngineConfig,\n    dims: EngineDimensions,\n)\n</code></pre> Given the change in constraint impulses <code>\u0394\u03bb</code>, the corresponding change in body velocities <code>\u0394u</code> is computed using the <code>compute_delta_body_qd_from_delta_lambda</code> method.</p>"},{"location":"implementation/engine/#d-update","title":"d) Update","text":"<p><pre><code>def update_variables(\n    model: Model,\n    data: EngineArrays,\n    config: EngineConfig,\n    dims: EngineDimensions,\n    dt: float,\n)\n</code></pre> The body velocities (<code>self.data.body_qd</code>) and constraint impulses (<code>self.data._lambda</code>) are updated with <code>update_variables</code>.</p>"},{"location":"implementation/engine/#3-finalize-state","title":"3. Finalize State","text":"<p>After the Newton loop completes, the final velocities (<code>self.data.body_qd</code>) and integrated positions (<code>self.data.body_q</code>) are copied to the <code>state_out</code>.</p>"},{"location":"implementation/engine/#gpu-acceleration-with-warp-kernels","title":"GPU Acceleration with Warp Kernels","text":"<p>All major computations in the <code>AxionEngine</code>, including constraint evaluation, system linearization, and iterative solving, are implemented as custom GPU kernels using the <code>wp.launch</code> from the Warp framework. Warp kernels enable highly parallel execution of physics operations, allowing the engine to efficiently process thousands of bodies and constraints in real time. Each stage of the simulation loop, from applying controls to solving the linear system and updating state variables, is mapped to specialized GPU kernels. This approach ensures that even complex, highly-constrained systems can be simulated with high performance and scalability.</p>"},{"location":"implementation/logging/","title":"Logging &amp; Analysis","text":"<p>TODO: Logging documentation</p>"},{"location":"implementation/parameters/","title":"Configurable Parameters","text":"<p>The physics engine exposes a variety of parameters that allow you to configure the simulation, solver, rendering and logging. How to work with these parameters was described in the Configuration System guide. Here, we provide a detailed explanation of the parameters. </p>"},{"location":"implementation/parameters/#engineconfig-tuning-the-solver","title":"<code>EngineConfig</code>: Tuning the Solver","text":"<p>The <code>EngineConfig</code> dataclass centralizes all parameters that control the solver's behavior. Below is a breakdown of these parameters, grouped by their function.</p> <pre><code>from axion import EngineConfig\n\n@dataclass(frozen=True)\nclass EngineConfig:\n    # Solver iterations\n    newton_iters: int = 8\n    linear_iters: int = 4\n    linesearch_steps: int = 2\n\n    # Baumgarte stabilization\n    joint_stabilization_factor: float = 0.01\n    contact_stabilization_factor: float = 0.1\n\n    # Fischer-Burmeister scaling\n    contact_fb_alpha: float = 0.25\n    contact_fb_beta: float = 0.25\n    friction_fb_alpha: float = 0.25\n    friction_fb_beta: float = 0.25\n\n    # Constraint compliance (softness)\n    contact_compliance: float = 1e-4\n    friction_compliance: float = 1e-6\n\n    # Performance\n    matrixfree_representation: bool = True\n</code></pre> <p>Built-in Validation</p> <p><code>EngineConfig</code> includes a <code>__post_init__</code> method that validates your settings. If you provide an invalid value (e.g., a negative number of iterations), it will immediately raise a <code>ValueError</code>, preventing hard-to-debug issues later.</p>"},{"location":"implementation/parameters/#group-1-solver-iterations","title":"Group 1: Solver Iterations","text":"<p>These parameters control the computational \"effort\" the solver expends at each time step.</p> Parameter Default Description <code>newton_iters</code> 8 Newton Iterations. The number of \"outer loop\" iterations for the nonlinear solver. More iterations lead to better constraint satisfaction (less penetration, stiffer joints). <code>linear_iters</code> 4 Linear Solver Iterations. The number of \"inner loop\" iterations for the Conjugate Residual solver, which solves the linearized system at each Newton step. <code>linesearch_steps</code> 2 Number of steps in the linesearch to find an optimal step size for each Newton update. Set to <code>0</code> to disable and take the full step."},{"location":"implementation/parameters/#group-2-baumgarte-stabilization","title":"Group 2: Baumgarte Stabilization","text":"<p>These parameters help the solver correct for positional drift from constraints over time.</p> Parameter Default Description <code>joint_stabilization_factor</code> 0.01 Joint Drift Correction. Controls how aggressively the solver corrects positional errors in joints. <code>contact_stabilization_factor</code> 0.1 Contact Penetration Correction. Controls how aggressively the solver pushes penetrating objects apart."},{"location":"implementation/parameters/#group-3-fischer-burmeister-fb-scaling","title":"Group 3: Fischer-Burmeister (FB) Scaling","text":"<p>These parameters are scaling factors for the Fischer-Burmeister function, which transforms a complementarity problem (like contact) into a root-finding problem that the Newton solver can handle.</p> Parameter Default Description <code>contact_fb_alpha</code> 0.25 Scales the primal variable (e.g., gap distance) of the contact complementarity problem. <code>contact_fb_beta</code> 0.25 Scales the dual variable (e.g., contact force \u03bb) of the contact complementarity problem. <code>friction_fb_alpha</code> 0.25 Scales the primal variable (e.g., relative velocity) of the friction complementarity problem. <code>friction_fb_beta</code> 0.25 Scales the dual variable (e.g., friction force \u03bb) of the friction complementarity problem. <p>What is Fischer-Burmeister Scaling?</p> <p>A contact constraint follows the rule <code>0 \u2264 distance \u22a5 force \u2265 0</code>. The FB function turns this into an equation <code>phi(distance, force) = 0</code>.</p> <p>However, <code>distance</code> (in meters) and <code>force</code> (in Newtons) can have vastly different numerical magnitudes. This imbalance can make the problem numerically difficult for the solver. The scaling factors <code>alpha</code> and <code>beta</code> are used to precondition the problem by solving a scaled version: <code>phi(alpha * distance, beta * force) = 0</code>.</p> <p>This brings the two arguments into a similar numerical range, improving the solver's stability and convergence speed.</p>"},{"location":"implementation/parameters/#group-4-constraint-compliance-softness","title":"Group 4: Constraint Compliance (Softness)","text":"<p>Compliance is the inverse of stiffness. These parameters introduce a controlled amount of \"softness,\" which can improve stability and simulate non-rigid behaviors.</p> Parameter Default Description <code>contact_compliance</code> 1e-4 Adds softness to contact constraints. <code>0.0</code> represents a perfectly hard contact. Larger values (e.g., <code>1e-2</code>) simulate softer materials. <code>friction_compliance</code> 1e-6 Adds softness to the friction model. This is typically kept very low to simulate rigid friction."},{"location":"implementation/parameters/#group-5-performance","title":"Group 5: Performance","text":"Parameter Default Description <code>matrixfree_representation</code> <code>True</code> If <code>True</code>, the solver uses matrix-free linear operators (memory-efficient). If <code>False</code>, it builds an explicit system matrix (can be faster for small systems)."},{"location":"implementation/parameters/#simulationconfig-general-simulation-parameters","title":"<code>SimulationConfig</code>: General Simulation Parameters","text":"<p>The <code>SimulationConfig</code> dataclass holds parameters for controlling the overall simulation behavior.</p> <pre><code>from axion import SimulationConfig\n\n@dataclass\nclass SimulationConfig:\n    duration_seconds: float = 3.0\n    target_timestep_seconds: float = 1e-3\n</code></pre> Parameter Default Description <code>duration_seconds</code> 3.0 Simulation Duration. Controls how long the simulation runs in seconds. <code>target_timestep_seconds</code> 0.001 Target Timestep. Controls the desired simulation timestep in seconds. If rendering is enabled, this parameter is recalculated to fit integer number of timesteps in 1/FPS seconds."},{"location":"implementation/parameters/#renderingconfig-visualization-settings","title":"<code>RenderingConfig</code>: Visualization Settings","text":"<p>The <code>RenderingConfig</code> dataclass holds parameters for controlling the visual output of the simulation. The rendering is done using the USD format, which can be viewed in tools like Blender or Pixar's USDView.</p> <pre><code>from axion import RenderingConfig\n\n@dataclass\nclass RenderingConfig:\n    enable: bool = True\n    fps: int = 30\n    scaling: float = 100.0\n    usd_file: str = \"sim.usd\"\n</code></pre> Parameter Default Description <code>enable</code> <code>True</code> If <code>True</code>, enables export of the simulation to a USD file. <code>fps</code> 30 Target frames per second for rendering. The simulation timestep is adjusted to fit an integer number of steps per frame. <code>scaling</code> 100.0 Scaling factor for the object meshes to convert from simulation units to meters. <code>usd_file</code> \"sim.usd\" The filename where the USD scene is saved, relative to the working directory."},{"location":"implementation/parameters/#executionconfig-execution-settings","title":"<code>ExecutionConfig</code>: Execution Settings","text":"<p>The <code>ExecutionConfig</code> dataclass holds parameters for controlling the performance and execution strategy of the simulation.</p> <pre><code>from axion import ExecutionConfig\n\n@dataclass\nclass ExecutionConfig:\n    use_cuda_graph: bool = True\n    headless_steps_per_segment: int = 10\n</code></pre> Parameter Default Description <code>use_cuda_graph</code> <code>True</code> If <code>True</code>, enables CUDA Graphs to minimize kernel launch overhead and improve performance. <code>headless_steps_per_segment</code> 10 Number of simulation steps to run in each headless segment when rendering is disabled."},{"location":"implementation/parameters/#profilingconfig-profiling-and-logging-settings","title":"<code>ProfilingConfig</code>: Profiling and Logging Settings","text":"<p>The <code>ProfilingConfig</code> dataclass holds parameters for controlling the profiling, timing and logging of the simulation. The logging is done using an HDF5-based logger, which records detailed simulation data for later analysis, for example using myHDF5.</p> <pre><code>from axion import ProfilingConfig\n\n@dataclass\nclass ProfilingConfig:\n    enable_timing: bool = False\n\n    # HDF5 Logging\n    enable_hdf5_logging: bool = False\n    hdf5_log_file: str = \"simulation.h5\"\n</code></pre> Parameter Default Description <code>enable_timing</code> <code>False</code> If <code>True</code>, enables detailed printing of timing of simulation stages. <code>enable_hdf5_logging</code> <code>False</code> If <code>True</code>, enables logging of detailed simulation data to an HDF5 file for later analysis. <code>hdf5_log_file</code> \"simulation.h5\" The filename where the HDF5 log is saved, relative to the working directory"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>axion<ul> <li>core<ul> <li>abstract_simulator</li> <li>engine</li> </ul> </li> <li>optim<ul> <li>matrix_operator</li> <li>matrixfree_operator</li> <li>preconditioner</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/axion/","title":"axion","text":"<p>An abstract base class for running a Warp-based physics simulation.</p> <p>Axion physics engine implementation using Warp.</p> <p>This module provides a linear operator that explicitly builds the full dense system matrix, mirroring the behavior of a direct matrix-based solver.</p> <p>The core component is the DenseSystemOperator class, which implements the matrix-vector product by first constructing the system matrix A, where:</p> <pre><code>A = (J M\u207b\u00b9 J\u1d40 + C)\n</code></pre> <ul> <li>J: The constraint Jacobian matrix.</li> <li>M: The block-diagonal mass matrix (inverse is M\u207b\u00b9).</li> <li>C: A diagonal compliance/regularization matrix.</li> </ul> <p>This operator is primarily useful for debugging, validation, or for smaller systems where the memory cost of the dense matrix is acceptable.</p> <p>This module provides a matrix-free linear operator for solving the mixed-integer system of equations that arises in velocity-based physics simulation.</p> <p>The core component is the SystemOperator class, which implements the matrix-vector product for the system matrix A, where:</p> <pre><code>A = (J M\u207b\u00b9 J\u1d40 + C)\n</code></pre> <ul> <li>J: The constraint Jacobian matrix.</li> <li>M: The block-diagonal mass matrix (inverse is M\u207b\u00b9).</li> <li>C: A diagonal compliance/regularization matrix.</li> </ul> <p>This operator is designed to be used with iterative linear solvers like Conjugate Residual (CR) or Conjugate Gradient (CG), allowing the system to be solved without ever forming the potentially very large and dense matrix A explicitly.</p> <p>Jacobi preconditioner for the system matrix A = J M\u207b\u00b9 J\u1d40 + C.</p>"},{"location":"reference/axion/#axion.core.abstract_simulator.AbstractSimulator","title":"<code>AbstractSimulator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class for running a Warp-based physics simulation.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>class AbstractSimulator(ABC):\n    \"\"\"An abstract base class for running a Warp-based physics simulation.\"\"\"\n\n    def __init__(\n        self,\n        simulation_config: SimulationConfig,\n        rendering_config: RenderingConfig,\n        execution_config: ExecutionConfig,\n        profiling_config: ProfilingConfig,\n        engine_config: EngineConfig,\n    ):\n        self.simulation_config = simulation_config\n        self.rendering_config = rendering_config\n        self.execution_config = execution_config\n        self.profiling_config = profiling_config\n        self.engine_config = engine_config\n\n        self.logger = (\n            HDF5Logger(self.profiling_config.hdf5_log_file)\n            if self.profiling_config.enable_hdf5_logging\n            else NullLogger()\n        )\n\n        self._current_step = 0\n        self._current_time = 0.0\n\n        # Calculated by _resolve_timing_parameters\n        self.steps_per_segment: int = 0\n        self.num_segments: int = 0\n        self.effective_timestep: float = 0.0\n        self.effective_duration: float = 0.0\n        self._resolve_timing_parameters()\n\n        self.model = self.build_model()\n\n        self.current_state = self.model.state()\n        self.next_state = self.model.state()\n        self.control = self.model.control()\n\n        if isinstance(self.engine_config, AxionEngineConfig):\n            self.integrator = AxionEngine(self.model, self.engine_config, self.logger)\n        elif isinstance(self.engine_config, FeatherstoneEngineConfig):\n            self.integrator = wp.sim.FeatherstoneIntegrator(self.model, **vars(self.engine_config))\n            wp.sim.eval_fk(\n                self.model, self.model.joint_q, self.model.joint_qd, None, self.current_state\n            )\n        elif isinstance(self.engine_config, SemiImplicitEngineConfig):\n            self.integrator = wp.sim.SemiImplicitIntegrator(**vars(self.engine_config))\n        elif isinstance(self.engine_config, XPBDEngineConfig):\n            self.integrator = wp.sim.XPBDIntegrator(**vars(self.engine_config))\n        else:\n            raise ValueError(f\"Unsupported engine configuration type: {type(self.engine_config)}\")\n\n        self.renderer: Optional[wp.sim.render.SimRenderer] = None\n        if self.rendering_config.enable:\n            self.renderer = wp.sim.render.SimRenderer(\n                self.model,\n                self.rendering_config.usd_file,\n                scaling=self.rendering_config.scaling,\n                fps=self.rendering_config.fps,\n            )\n\n        self.cuda_graph: Optional[wp.Graph] = None\n\n        num_substeps = self.steps_per_segment\n        self.start_events = [wp.Event(enable_timing=True) for _ in range(num_substeps)]\n        self.collision_events = [wp.Event(enable_timing=True) for _ in range(num_substeps)]\n        self.integration_events = [wp.Event(enable_timing=True) for _ in range(num_substeps)]\n\n        self.events = [\n            {\n                \"step_start\": wp.Event(enable_timing=True),\n                \"collision\": wp.Event(enable_timing=True),\n                \"integration\": wp.Event(enable_timing=True),\n                \"integration_parts\": None,\n            }\n            for _ in range(num_substeps)\n        ]\n\n        self.simulation_events = [[] for _ in range(num_substeps)]\n\n    def run(self):\n        \"\"\"Main entry point to start the simulation.\"\"\"\n        disable_progress = self.profiling_config.enable_timing\n        with self.logger:\n            for i in tqdm(\n                range(self.num_segments),\n                desc=\"Simulating\",\n                disable=disable_progress,\n            ):\n                self._run_simulation_segment(i)\n\n                if self.rendering_config.enable:\n                    wp.synchronize()\n                    time = (i + 1) * (1.0 / self.rendering_config.fps)\n                    self.renderer.begin_frame(time)\n                    self.renderer.render(self.current_state)\n                    self.renderer.end_frame()\n\n        if self.rendering_config.enable:\n            self.renderer.save()\n            print(f\"Rendering complete. Output saved to {self.rendering_config.usd_file}\")\n        else:\n            wp.synchronize()\n            print(\"Headless simulation complete.\")\n\n    def _run_simulation_segment(self, segment_num: int):\n        \"\"\"Executes a single simulation segment, using the chosen execution path.\"\"\"\n        if self.use_cuda_graph:\n            self._run_segment_with_graph(segment_num)\n        else:\n            self._run_segment_without_graph(segment_num)\n\n    def _run_segment_without_graph(self, segment_num: int):\n        \"\"\"Runs a segment by iterating and launching each step's kernels individually.\"\"\"\n        n_steps = self.steps_per_segment\n        timer_msg = f\"SEGMENT {segment_num}/{self.num_segments}: Simulation of {n_steps} time steps\"\n        with wp.ScopedTimer(\n            timer_msg,\n            active=self.profiling_config.enable_timing,\n            synchronize=True,\n        ):\n            for step in range(n_steps):\n                self._single_physics_step(step)\n\n                # Update attributes for logging\n                self._current_step += 1\n                self._current_time += self.effective_timestep\n\n        if self.profiling_config.enable_timing:\n            self._log_segment_timings()\n\n    def _run_segment_with_graph(self, segment_num: int):\n        \"\"\"Runs a segment by launching a pre-captured CUDA graph.\"\"\"\n        if self.cuda_graph is None:\n            self._capture_cuda_graph()\n\n        n_steps = self.steps_per_segment\n        timer_msg = f\"SEGMENT {segment_num}/{self.num_segments}: Simulation of {n_steps} time steps (with CUDA graph)\"\n        with wp.ScopedTimer(\n            timer_msg,\n            active=self.profiling_config.enable_timing,\n            synchronize=True,\n        ):\n            wp.capture_launch(self.cuda_graph)\n\n        if self.profiling_config.enable_timing:\n            self._log_segment_timings()\n\n    def _log_segment_timings(self):\n        \"\"\"Logs the detailed timing information for the most recent segment.\"\"\"\n        for step in range(self.steps_per_segment):\n            collision_time = wp.get_event_elapsed_time(\n                self.events[step][\"step_start\"],\n                self.events[step][\"collision\"],\n            )\n            integration_time = wp.get_event_elapsed_time(\n                self.events[step][\"collision\"],\n                self.events[step][\"integration\"],\n            )\n\n            print(\n                f\"\\t- SUBSTEP {step}: collision detection took {collision_time:.03f} ms \"\n                f\"and simulation step took {integration_time:0.3f} ms.\"\n            )\n\n            # Check if detailed integrator events were captured\n            if self.events[step][\"integration_parts\"] is None:\n                continue\n\n            for newton_iter in range(self.engine_config.newton_iters):\n                events = self.events[step][\"integration_parts\"][newton_iter]\n                linearize_time = wp.get_event_elapsed_time(\n                    events[\"iter_start\"], events[\"linearize\"]\n                )\n                lin_solve_time = wp.get_event_elapsed_time(events[\"linearize\"], events[\"lin_solve\"])\n                linesearch_time = wp.get_event_elapsed_time(\n                    events[\"lin_solve\"], events[\"linesearch\"]\n                )\n\n                print(\n                    f\"\\t\\t- NEWTON ITERATION {newton_iter}: Linearization took {linearize_time:.03f} ms, \"\n                    f\"solving of linear system took {lin_solve_time:.03f} ms and linesearch took {linesearch_time:.03f} ms.\"\n                )\n\n    def _capture_cuda_graph(self):\n        \"\"\"Records the sequence of operations for one segment into a CUDA graph.\"\"\"\n        n_steps = self.steps_per_segment\n        with wp.ScopedCapture() as capture:\n            for i in range(n_steps):\n                self._single_physics_step(i)\n        self.cuda_graph = capture.graph\n\n    def _single_physics_step(self, step_num: int):\n        \"\"\"Performs one fundamental integration step of the simulation.\"\"\"\n        with self.logger.scope(f\"timestep_{self._current_step:04d}\"):\n            self.logger.log_scalar(\"time\", self._current_time)\n\n            # Record that step started\n            wp.record_event(self.events[step_num][\"step_start\"])\n\n            # Detect collisions\n            wp.sim.collide(self.model, self.current_state)\n\n            # Record that collision detection finished\n            wp.record_event(self.events[step_num][\"collision\"])\n            self.logger.log_wp_dataset(\"rigid_contact_count\", self.model.rigid_contact_count)\n\n            # Compute simulation step\n            self.events[step_num][\"integration_parts\"] = self.integrator.simulate(\n                model=self.model,\n                state_in=self.current_state,\n                state_out=self.next_state,\n                dt=self.effective_timestep,\n                control=self.control,\n            )\n\n            # Record that simulation step finished\n            wp.record_event(self.events[step_num][\"integration\"])\n\n            wp.copy(dest=self.current_state.body_q, src=self.next_state.body_q)\n            wp.copy(dest=self.current_state.body_qd, src=self.next_state.body_qd)\n\n    def _resolve_timing_parameters(self):\n        \"\"\"\n        Calculates all operational timing parameters based on user configuration,\n        ensuring alignment between simulation, rendering, and segmentation.\n        \"\"\"\n        if self.rendering_config.enable:\n            self.effective_timestep, self.steps_per_segment = calculate_render_aligned_timestep(\n                self.simulation_config.target_timestep_seconds, self.rendering_config.fps\n            )\n        else:\n            self.effective_timestep = self.simulation_config.target_timestep_seconds\n            self.steps_per_segment = self.execution_config.headless_steps_per_segment\n\n        self.effective_duration, self.num_segments = align_duration_to_segment(\n            self.simulation_config.duration_seconds, self.effective_timestep, self.steps_per_segment\n        )\n\n    @property\n    def use_cuda_graph(self) -&gt; bool:\n        \"\"\"Determines if conditions are met to use CUDA graph optimization.\"\"\"\n        return (\n            self.execution_config.use_cuda_graph\n            and wp.get_device().is_cuda\n            and not self.profiling_config.enable_hdf5_logging\n        )\n\n    @abstractmethod\n    def build_model(self) -&gt; wp.sim.Model:\n        \"\"\"\n        Builds the physics model for the simulation.\n\n        This method MUST be implemented by any subclass. It should define all the\n        rigid bodies, joints, and other physical properties of the scene.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.AbstractSimulator.use_cuda_graph","title":"<code>use_cuda_graph</code>  <code>property</code>","text":"<p>Determines if conditions are met to use CUDA graph optimization.</p>"},{"location":"reference/axion/#axion.core.abstract_simulator.AbstractSimulator.build_model","title":"<code>build_model</code>  <code>abstractmethod</code>","text":"<p>Builds the physics model for the simulation.</p> <p>This method MUST be implemented by any subclass. It should define all the rigid bodies, joints, and other physical properties of the scene.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@abstractmethod\ndef build_model(self) -&gt; wp.sim.Model:\n    \"\"\"\n    Builds the physics model for the simulation.\n\n    This method MUST be implemented by any subclass. It should define all the\n    rigid bodies, joints, and other physical properties of the scene.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.AbstractSimulator.run","title":"<code>run</code>","text":"<p>Main entry point to start the simulation.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>def run(self):\n    \"\"\"Main entry point to start the simulation.\"\"\"\n    disable_progress = self.profiling_config.enable_timing\n    with self.logger:\n        for i in tqdm(\n            range(self.num_segments),\n            desc=\"Simulating\",\n            disable=disable_progress,\n        ):\n            self._run_simulation_segment(i)\n\n            if self.rendering_config.enable:\n                wp.synchronize()\n                time = (i + 1) * (1.0 / self.rendering_config.fps)\n                self.renderer.begin_frame(time)\n                self.renderer.render(self.current_state)\n                self.renderer.end_frame()\n\n    if self.rendering_config.enable:\n        self.renderer.save()\n        print(f\"Rendering complete. Output saved to {self.rendering_config.usd_file}\")\n    else:\n        wp.synchronize()\n        print(\"Headless simulation complete.\")\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.ExecutionConfig","title":"<code>ExecutionConfig</code>  <code>dataclass</code>","text":"<p>Parameters controlling the performance and execution strategy.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass ExecutionConfig:\n    \"\"\"Parameters controlling the performance and execution strategy.\"\"\"\n\n    use_cuda_graph: bool = True\n    headless_steps_per_segment: int = 10\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.ProfilingConfig","title":"<code>ProfilingConfig</code>  <code>dataclass</code>","text":"<p>Parameters for debugging, timing, and logging.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass ProfilingConfig:\n    \"\"\"Parameters for debugging, timing, and logging.\"\"\"\n\n    enable_timing: bool = False\n\n    # Enables HDF5 logging (disables CUDA graph optimization).\n    enable_hdf5_logging: bool = False\n    hdf5_log_file: str = \"simulation.h5\"\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.RenderingConfig","title":"<code>RenderingConfig</code>  <code>dataclass</code>","text":"<p>Parameters for rendering the simulation to a USD file.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass RenderingConfig:\n    \"\"\"Parameters for rendering the simulation to a USD file.\"\"\"\n\n    enable: bool = True\n    fps: int = 30\n    scaling: float = 100.0\n    usd_file: str = \"sim.usd\"\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.SimulationConfig","title":"<code>SimulationConfig</code>  <code>dataclass</code>","text":"<p>Parameters defining the simulation's timeline.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass SimulationConfig:\n    \"\"\"Parameters defining the simulation's timeline.\"\"\"\n\n    duration_seconds: float = 3.0\n    target_timestep_seconds: float = 1e-3\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.align_duration_to_segment","title":"<code>align_duration_to_segment</code>","text":"<p>Adjusts total simulation duration to be a whole multiple of the segment duration.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>def align_duration_to_segment(target_duration: float, timestep: float, steps_per_segment: int):\n    \"\"\"Adjusts total simulation duration to be a whole multiple of the segment duration.\"\"\"\n    segment_duration = timestep * steps_per_segment\n    num_segments = math.ceil(target_duration / segment_duration)\n    total_sim_steps = num_segments * steps_per_segment\n    effective_duration = total_sim_steps * timestep\n\n    adj_ratio = abs(effective_duration - target_duration) / target_duration\n    if adj_ratio &gt; 0.01:\n        print(\n            f\"\\nINFO: Simulation duration adjusted to {effective_duration:.4f}s \"\n            f\"to align with segment size. ({100 * adj_ratio:.3}% change)\"\n        )\n    return effective_duration, num_segments\n</code></pre>"},{"location":"reference/axion/#axion.core.abstract_simulator.calculate_render_aligned_timestep","title":"<code>calculate_render_aligned_timestep</code>","text":"<p>Calculates an effective timestep that aligns perfectly with render frame duration.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>def calculate_render_aligned_timestep(target_timestep_seconds: float, fps: int):\n    \"\"\"Calculates an effective timestep that aligns perfectly with render frame duration.\"\"\"\n    frame_duration = 1.0 / fps\n    ideal_steps_per_frame = frame_duration / target_timestep_seconds\n    steps_per_frame = round(ideal_steps_per_frame) or 1\n    effective_timestep = frame_duration / steps_per_frame\n\n    adj_ratio = abs(effective_timestep - target_timestep_seconds) / target_timestep_seconds\n    if adj_ratio &gt; 0.01:\n        print(\n            f\"\\nINFO: Target timestep adjusted to {1000 * effective_timestep:.3f}ms\"\n            f\" for rendering. ({100 * adj_ratio:.3}% change)\"\n        )\n\n    return effective_timestep, steps_per_frame\n</code></pre>"},{"location":"reference/axion/#axion.core.engine.AxionEngine","title":"<code>AxionEngine</code>","text":"<p>               Bases: <code>Integrator</code></p> <p>The class implements a low-level physics solver. The engine implements a Non-Smooth Newton Method to solve the entire physics state\u2014including dynamics, contacts, and joints\u2014as a single, unified problem at each time step. This monolithic approach provides exceptional stability, especially for complex, highly-constrained systems like articulated robots.</p> Source code in <code>src/axion/core/engine.py</code> <pre><code>class AxionEngine(Integrator):\n    \"\"\"\n    The class implements a low-level physics solver.\n    The engine implements a Non-Smooth Newton Method to solve\n    the entire physics state\u2014including dynamics, contacts,\n    and joints\u2014as a single, unified problem at each time step.\n    This monolithic approach provides exceptional stability,\n    especially for complex, highly-constrained systems like\n    articulated robots.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: Model,\n        config: Optional[AxionEngineConfig],\n        logger: Optional[HDF5Logger | NullLogger],\n    ):\n        \"\"\"\n        Initialize the physics engine for the given model and configuration.\n\n        Args:\n            model: The warp.sim.Model physics model containing bodies, joints, and other physics properties.\n            config: Configuration parameters for the engine of type EngineConfig.\n            logger: Optional HDF5Logger or NullLogger for recording simulation data.\n        \"\"\"\n        super().__init__()\n        self.device = model.device\n\n        self.model = model\n        self.logger = logger\n        self.config = config\n\n        self.dims = EngineDimensions(\n            N_b=self.model.body_count,\n            N_c=self.model.rigid_contact_max,\n            N_j=self.model.joint_count,\n            N_alpha=self.config.linesearch_steps,\n        )\n\n        allocate_dense_matrices = isinstance(self.logger, HDF5Logger)\n        self.data = create_engine_arrays(self.dims, self.device, allocate_dense_matrices)\n\n        if self.config.matrixfree_representation:\n            self.A_op = MatrixFreeSystemOperator(self)\n        else:\n            self.A_op = MatrixSystemOperator(self)\n\n        self.preconditioner = JacobiPreconditioner(self)\n\n        self.data.set_generalized_mass(model)\n        self.data.set_gravitational_acceleration(model)\n\n        self.events = [\n            {\n                \"iter_start\": wp.Event(enable_timing=True),\n                \"linearize\": wp.Event(enable_timing=True),\n                \"lin_solve\": wp.Event(enable_timing=True),\n                \"linesearch\": wp.Event(enable_timing=True),\n            }\n            for _ in range(self.config.newton_iters)\n        ]\n\n    def _log_newton_iteration_data(self):\n        if isinstance(self.logger, NullLogger):\n            return\n\n        self.logger.log_wp_dataset(\"res\", self.data.res)\n        self.logger.log_wp_dataset(\"J_values\", self.data.J_values)\n        self.logger.log_wp_dataset(\"C_values\", self.data.C_values)\n        self.logger.log_wp_dataset(\"constraint_body_idx\", self.data.constraint_body_idx)\n\n        self.logger.log_wp_dataset(\"body_f\", self.data.body_f)\n        self.logger.log_wp_dataset(\"body_q\", self.data.body_q)\n        self.logger.log_wp_dataset(\"body_qd\", self.data.body_qd)\n        self.logger.log_wp_dataset(\"body_qd_prev\", self.data.body_qd_prev)\n\n        self.logger.log_wp_dataset(\"lambda\", self.data._lambda)\n        self.logger.log_wp_dataset(\"lambda_prev\", self.data.lambda_prev)\n\n        self.logger.log_wp_dataset(\"delta_body_qd\", self.data.delta_body_qd)\n        self.logger.log_wp_dataset(\"delta_lambda\", self.data.delta_lambda)\n\n        self.logger.log_wp_dataset(\"b\", self.data.b)\n\n        self.logger.log_struct_array(\"gen_mass\", self.data.gen_mass)\n        self.logger.log_struct_array(\"gen_inv_mass\", self.data.gen_inv_mass)\n\n        self.logger.log_struct_array(\"joint_interaction\", self.data.joint_interaction)\n        self.logger.log_struct_array(\"contact_interaction\", self.data.contact_interaction)\n\n        update_dense_matrices(self.data, self.config, self.dims)\n\n        self.logger.log_wp_dataset(\"Minv_dense\", self.data.Minv_dense)\n        self.logger.log_wp_dataset(\"J_dense\", self.data.J_dense)\n        self.logger.log_wp_dataset(\"C_dense\", self.data.C_dense)\n\n        if not self.config.matrixfree_representation:\n            self.logger.log_wp_dataset(\"A_dense\", self.A_op._A)\n        else:\n            A_np = get_system_matrix_numpy(self.data, self.config, self.dims)\n            cond_number = np.linalg.cond(A_np)\n            self.logger.log_np_dataset(\"A_np\", A_np)\n            self.logger.log_scalar(\"cond_number\", cond_number)\n\n    def _log_static_data(self):\n        if isinstance(self.logger, NullLogger):\n            return\n\n        self.logger.log_wp_dataset(\"gen_mass\", self.data.gen_mass)\n        self.logger.log_wp_dataset(\"gen_inv_mass\", self.data.gen_inv_mass)\n\n    def simulate(\n        self,\n        model: Model,\n        state_in: State,\n        state_out: State,\n        dt: float,\n        control: Control | None = None,\n    ):\n        \"\"\"\n        The primary method for running the physics simulation for a single time step.\n        This method is an implementation of the abstract method from the base `Integrator` class in Warp.\n\n        Args:\n            model: The physics model containing bodies, joints, and other physics properties.\n            state_in: The input state at the beginning of the time step.\n            state_out: The output state at the end of the time step. This will be modified by the engine.\n            dt: The time step duration.\n            control: Optional control inputs to be applied during the simulation step.\n        \"\"\"\n        apply_control(model, state_in, state_out, dt, control)\n        self.integrate_bodies(model, state_in, state_out, dt)\n        self.data.update_state_data(model, state_in, state_out)\n\n        # TODO: Check the warm startup\n        # self._lambda.zero_()\n\n        for i in range(self.config.newton_iters):\n            wp.record_event(self.events[i][\"iter_start\"])\n\n            with self.logger.scope(f\"newton_iteration_{i:02d}\"):\n                wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n                wp.copy(dest=self.data.lambda_n_scale_prev, src=self.data.lambda_n_scale)\n\n                # --- Linearize the system of equations ---\n                compute_linear_system(self.model, self.data, self.config, self.dims, dt)\n                wp.record_event(self.events[i][\"linearize\"])\n\n                if not self.config.matrixfree_representation:\n                    self.A_op.update()\n                self.preconditioner.update()\n\n                # --- Solve linear system of equations ---\n                cr_solver(\n                    A=self.A_op,\n                    b=self.data.b,\n                    x=self.data.delta_lambda,\n                    iters=self.config.linear_iters,\n                    preconditioner=self.preconditioner,\n                    logger=self.logger,\n                )\n\n                compute_delta_body_qd_from_delta_lambda(self.data, self.config, self.dims)\n                wp.record_event(self.events[i][\"lin_solve\"])\n\n                if self.config.linesearch_steps &gt; 0:\n                    perform_linesearch(self.data, self.config, self.dims, dt)\n                wp.record_event(self.events[i][\"linesearch\"])\n\n                update_variables(self.model, self.data, self.config, self.dims, dt)\n\n                self._log_newton_iteration_data()\n\n        update_body_q(self.model, self.data, self.config, self.dims, dt)\n        wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n        wp.copy(dest=state_out.body_q, src=self.data.body_q)\n\n        return self.events\n\n    def simulate_scipy(\n        self,\n        model: Model,\n        state_in: State,\n        state_out: State,\n        dt: float,\n        control: Control | None = None,\n        method: str = \"hybr\",\n        tolerance: float = 1e-10,\n        max_iterations: int = 5000,\n    ):\n        \"\"\"\n        Apply the SciPy root-finding algorithm to the simulation.\n\n        Args:\n            model: The physics model containing bodies, joints, and other physics properties.\n            state_in: The input state at the beginning of the time step.\n            state_out: The output state at the end of the time step. This will be modified by the engine.\n            dt: The time step duration.\n            control: Optional control inputs to be applied during the simulation step.\n            method: The scipy root-finding method to use (default is 'hybr').\n            tolerance: The tolerance for convergence (default is 1e-10).\n            max_iterations: The maximum number of iterations for the solver (default is 5000).\n        \"\"\"\n        apply_control(model, state_in, state_out, dt, control)\n        self.integrate_bodies(model, state_in, state_out, dt)\n        self.data.update_state_data(model, state_in, state_out)\n\n        def residual_function(x: np.ndarray) -&gt; np.ndarray:\n            wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n\n            # x contains both lambda and body_qd\n            n_lambda = self.dims.con_dim\n            lambda_vals = x[:n_lambda]\n            body_qd_vals = x[n_lambda:]\n\n            # Store current state\n            lambda_backup = wp.clone(self.data._lambda)\n            body_qd_backup = wp.clone(self.data.body_qd)\n\n            try:\n                # Set state from input vector\n                self.data._lambda.assign(lambda_vals)\n                self.data.body_qd.assign(body_qd_vals)\n\n                # Compute residuals (right hand side of the linear system)\n                compute_linear_system(self.data, self.config, self.dims, dt)\n\n                # Residual is concatenation of g and h vector\n                return self.data.res.numpy()\n\n            finally:\n                # Restore original state\n                wp.copy(dest=self.data._lambda, src=lambda_backup)\n                wp.copy(dest=self.data.body_qd, src=body_qd_backup)\n\n        # Initial guess from current state\n        x0 = np.concatenate([self.data._lambda.numpy(), self.data.body_qd.numpy().flatten()])\n\n        # Solve\n        result = scipy.optimize.root(\n            residual_function,\n            x0,\n            method=method,\n            options={\"xtol\": tolerance, \"maxfev\": max_iterations},\n        )\n\n        n_lambda = self.dims.con_dim\n        self.data._lambda.assign(wp.from_numpy(result.x[:n_lambda].astype(np.float32)))\n        body_qd_solution = result.x[n_lambda:][np.newaxis, :]\n        self.data.body_qd.assign(wp.from_numpy(body_qd_solution.astype(np.float32)))\n\n        wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n        wp.copy(dest=state_out.body_q, src=self.data.body_q)\n</code></pre>"},{"location":"reference/axion/#axion.core.engine.AxionEngine.__init__","title":"<code>__init__</code>","text":"<p>Initialize the physics engine for the given model and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The warp.sim.Model physics model containing bodies, joints, and other physics properties.</p> required <code>config</code> <code>Optional[AxionEngineConfig]</code> <p>Configuration parameters for the engine of type EngineConfig.</p> required <code>logger</code> <code>Optional[HDF5Logger | NullLogger]</code> <p>Optional HDF5Logger or NullLogger for recording simulation data.</p> required Source code in <code>src/axion/core/engine.py</code> <pre><code>def __init__(\n    self,\n    model: Model,\n    config: Optional[AxionEngineConfig],\n    logger: Optional[HDF5Logger | NullLogger],\n):\n    \"\"\"\n    Initialize the physics engine for the given model and configuration.\n\n    Args:\n        model: The warp.sim.Model physics model containing bodies, joints, and other physics properties.\n        config: Configuration parameters for the engine of type EngineConfig.\n        logger: Optional HDF5Logger or NullLogger for recording simulation data.\n    \"\"\"\n    super().__init__()\n    self.device = model.device\n\n    self.model = model\n    self.logger = logger\n    self.config = config\n\n    self.dims = EngineDimensions(\n        N_b=self.model.body_count,\n        N_c=self.model.rigid_contact_max,\n        N_j=self.model.joint_count,\n        N_alpha=self.config.linesearch_steps,\n    )\n\n    allocate_dense_matrices = isinstance(self.logger, HDF5Logger)\n    self.data = create_engine_arrays(self.dims, self.device, allocate_dense_matrices)\n\n    if self.config.matrixfree_representation:\n        self.A_op = MatrixFreeSystemOperator(self)\n    else:\n        self.A_op = MatrixSystemOperator(self)\n\n    self.preconditioner = JacobiPreconditioner(self)\n\n    self.data.set_generalized_mass(model)\n    self.data.set_gravitational_acceleration(model)\n\n    self.events = [\n        {\n            \"iter_start\": wp.Event(enable_timing=True),\n            \"linearize\": wp.Event(enable_timing=True),\n            \"lin_solve\": wp.Event(enable_timing=True),\n            \"linesearch\": wp.Event(enable_timing=True),\n        }\n        for _ in range(self.config.newton_iters)\n    ]\n</code></pre>"},{"location":"reference/axion/#axion.core.engine.AxionEngine.simulate","title":"<code>simulate</code>","text":"<p>The primary method for running the physics simulation for a single time step. This method is an implementation of the abstract method from the base <code>Integrator</code> class in Warp.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The physics model containing bodies, joints, and other physics properties.</p> required <code>state_in</code> <code>State</code> <p>The input state at the beginning of the time step.</p> required <code>state_out</code> <code>State</code> <p>The output state at the end of the time step. This will be modified by the engine.</p> required <code>dt</code> <code>float</code> <p>The time step duration.</p> required <code>control</code> <code>Control | None</code> <p>Optional control inputs to be applied during the simulation step.</p> <code>None</code> Source code in <code>src/axion/core/engine.py</code> <pre><code>def simulate(\n    self,\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    control: Control | None = None,\n):\n    \"\"\"\n    The primary method for running the physics simulation for a single time step.\n    This method is an implementation of the abstract method from the base `Integrator` class in Warp.\n\n    Args:\n        model: The physics model containing bodies, joints, and other physics properties.\n        state_in: The input state at the beginning of the time step.\n        state_out: The output state at the end of the time step. This will be modified by the engine.\n        dt: The time step duration.\n        control: Optional control inputs to be applied during the simulation step.\n    \"\"\"\n    apply_control(model, state_in, state_out, dt, control)\n    self.integrate_bodies(model, state_in, state_out, dt)\n    self.data.update_state_data(model, state_in, state_out)\n\n    # TODO: Check the warm startup\n    # self._lambda.zero_()\n\n    for i in range(self.config.newton_iters):\n        wp.record_event(self.events[i][\"iter_start\"])\n\n        with self.logger.scope(f\"newton_iteration_{i:02d}\"):\n            wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n            wp.copy(dest=self.data.lambda_n_scale_prev, src=self.data.lambda_n_scale)\n\n            # --- Linearize the system of equations ---\n            compute_linear_system(self.model, self.data, self.config, self.dims, dt)\n            wp.record_event(self.events[i][\"linearize\"])\n\n            if not self.config.matrixfree_representation:\n                self.A_op.update()\n            self.preconditioner.update()\n\n            # --- Solve linear system of equations ---\n            cr_solver(\n                A=self.A_op,\n                b=self.data.b,\n                x=self.data.delta_lambda,\n                iters=self.config.linear_iters,\n                preconditioner=self.preconditioner,\n                logger=self.logger,\n            )\n\n            compute_delta_body_qd_from_delta_lambda(self.data, self.config, self.dims)\n            wp.record_event(self.events[i][\"lin_solve\"])\n\n            if self.config.linesearch_steps &gt; 0:\n                perform_linesearch(self.data, self.config, self.dims, dt)\n            wp.record_event(self.events[i][\"linesearch\"])\n\n            update_variables(self.model, self.data, self.config, self.dims, dt)\n\n            self._log_newton_iteration_data()\n\n    update_body_q(self.model, self.data, self.config, self.dims, dt)\n    wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n    wp.copy(dest=state_out.body_q, src=self.data.body_q)\n\n    return self.events\n</code></pre>"},{"location":"reference/axion/#axion.core.engine.AxionEngine.simulate_scipy","title":"<code>simulate_scipy</code>","text":"<p>Apply the SciPy root-finding algorithm to the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The physics model containing bodies, joints, and other physics properties.</p> required <code>state_in</code> <code>State</code> <p>The input state at the beginning of the time step.</p> required <code>state_out</code> <code>State</code> <p>The output state at the end of the time step. This will be modified by the engine.</p> required <code>dt</code> <code>float</code> <p>The time step duration.</p> required <code>control</code> <code>Control | None</code> <p>Optional control inputs to be applied during the simulation step.</p> <code>None</code> <code>method</code> <code>str</code> <p>The scipy root-finding method to use (default is 'hybr').</p> <code>'hybr'</code> <code>tolerance</code> <code>float</code> <p>The tolerance for convergence (default is 1e-10).</p> <code>1e-10</code> <code>max_iterations</code> <code>int</code> <p>The maximum number of iterations for the solver (default is 5000).</p> <code>5000</code> Source code in <code>src/axion/core/engine.py</code> <pre><code>def simulate_scipy(\n    self,\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    control: Control | None = None,\n    method: str = \"hybr\",\n    tolerance: float = 1e-10,\n    max_iterations: int = 5000,\n):\n    \"\"\"\n    Apply the SciPy root-finding algorithm to the simulation.\n\n    Args:\n        model: The physics model containing bodies, joints, and other physics properties.\n        state_in: The input state at the beginning of the time step.\n        state_out: The output state at the end of the time step. This will be modified by the engine.\n        dt: The time step duration.\n        control: Optional control inputs to be applied during the simulation step.\n        method: The scipy root-finding method to use (default is 'hybr').\n        tolerance: The tolerance for convergence (default is 1e-10).\n        max_iterations: The maximum number of iterations for the solver (default is 5000).\n    \"\"\"\n    apply_control(model, state_in, state_out, dt, control)\n    self.integrate_bodies(model, state_in, state_out, dt)\n    self.data.update_state_data(model, state_in, state_out)\n\n    def residual_function(x: np.ndarray) -&gt; np.ndarray:\n        wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n\n        # x contains both lambda and body_qd\n        n_lambda = self.dims.con_dim\n        lambda_vals = x[:n_lambda]\n        body_qd_vals = x[n_lambda:]\n\n        # Store current state\n        lambda_backup = wp.clone(self.data._lambda)\n        body_qd_backup = wp.clone(self.data.body_qd)\n\n        try:\n            # Set state from input vector\n            self.data._lambda.assign(lambda_vals)\n            self.data.body_qd.assign(body_qd_vals)\n\n            # Compute residuals (right hand side of the linear system)\n            compute_linear_system(self.data, self.config, self.dims, dt)\n\n            # Residual is concatenation of g and h vector\n            return self.data.res.numpy()\n\n        finally:\n            # Restore original state\n            wp.copy(dest=self.data._lambda, src=lambda_backup)\n            wp.copy(dest=self.data.body_qd, src=body_qd_backup)\n\n    # Initial guess from current state\n    x0 = np.concatenate([self.data._lambda.numpy(), self.data.body_qd.numpy().flatten()])\n\n    # Solve\n    result = scipy.optimize.root(\n        residual_function,\n        x0,\n        method=method,\n        options={\"xtol\": tolerance, \"maxfev\": max_iterations},\n    )\n\n    n_lambda = self.dims.con_dim\n    self.data._lambda.assign(wp.from_numpy(result.x[:n_lambda].astype(np.float32)))\n    body_qd_solution = result.x[n_lambda:][np.newaxis, :]\n    self.data.body_qd.assign(wp.from_numpy(body_qd_solution.astype(np.float32)))\n\n    wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n    wp.copy(dest=state_out.body_q, src=self.data.body_q)\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrix_operator.MatrixSystemOperator","title":"<code>MatrixSystemOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator that explicitly builds the dense system matrix A = J M\u207b\u00b9 J\u1d40 + C and uses it for matrix-vector products.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>class MatrixSystemOperator(LinearOperator):\n    \"\"\"\n    A linear operator that explicitly builds the dense system matrix A = J M\u207b\u00b9 J\u1d40 + C\n    and uses it for matrix-vector products.\n    \"\"\"\n\n    def __init__(self, engine):\n        super().__init__(\n            shape=(engine.dims.con_dim, engine.dims.con_dim),\n            dtype=wp.float32,\n            device=engine.device,\n            matvec=None,\n        )\n        self.engine = engine\n\n        # Allocate memory for the full dense matrix\n        self._A = wp.zeros(self.shape, dtype=self.dtype, device=self.device)\n\n    def update(self):\n        \"\"\"Re-computes the dense system matrix _A using the latest system state.\"\"\"\n        self._A.zero_()\n        wp.launch(\n            kernel=update_system_matrix_kernel,\n            dim=self.shape,\n            inputs=[\n                self.engine.data.gen_inv_mass,\n                self.engine.data.constraint_body_idx,\n                self.engine.data.J_values,\n                self.engine.data.C_values,\n            ],\n            outputs=[self._A],\n            device=self.device,\n        )\n\n    def matvec(self, x, y, z, alpha, beta):\n        \"\"\"Computes z = beta * y + alpha * (A @ x) via dense matrix-vector product.\"\"\"\n        A = aslinearoperator(self._A)\n        A.matvec(x=x, y=y, z=z, alpha=alpha, beta=beta)\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrix_operator.MatrixSystemOperator.matvec","title":"<code>matvec</code>","text":"<p>Computes z = beta * y + alpha * (A @ x) via dense matrix-vector product.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>def matvec(self, x, y, z, alpha, beta):\n    \"\"\"Computes z = beta * y + alpha * (A @ x) via dense matrix-vector product.\"\"\"\n    A = aslinearoperator(self._A)\n    A.matvec(x=x, y=y, z=z, alpha=alpha, beta=beta)\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrix_operator.MatrixSystemOperator.update","title":"<code>update</code>","text":"<p>Re-computes the dense system matrix _A using the latest system state.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>def update(self):\n    \"\"\"Re-computes the dense system matrix _A using the latest system state.\"\"\"\n    self._A.zero_()\n    wp.launch(\n        kernel=update_system_matrix_kernel,\n        dim=self.shape,\n        inputs=[\n            self.engine.data.gen_inv_mass,\n            self.engine.data.constraint_body_idx,\n            self.engine.data.J_values,\n            self.engine.data.C_values,\n        ],\n        outputs=[self._A],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrix_operator.update_system_matrix_kernel","title":"<code>update_system_matrix_kernel</code>","text":"<p>Builds the full dense system matrix A = J M\u207b\u00b9 J\u1d40 + C.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>@wp.kernel\ndef update_system_matrix_kernel(\n    body_spatial_inertia: wp.array(dtype=SpatialInertia),\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    C_values: wp.array(dtype=wp.float32),\n    A: wp.array(dtype=wp.float32, ndim=2),\n):\n    \"\"\"Builds the full dense system matrix A = J M\u207b\u00b9 J\u1d40 + C.\"\"\"\n    i, j = wp.tid()\n\n    body_a_i = constraint_body_idx[i, 0]\n    body_b_i = constraint_body_idx[i, 1]\n    J_ia = J_values[i, 0]\n    J_ib = J_values[i, 1]\n\n    body_a_j = constraint_body_idx[j, 0]\n    body_b_j = constraint_body_idx[j, 1]\n    J_ja = J_values[j, 0]\n    J_jb = J_values[j, 1]\n\n    if body_a_i == body_b_i or body_a_j == body_b_j:\n        A[i, j] = 0.0\n\n    A_ij = 0.0\n\n    # Term 1: body_a_i vs body_a_j\n    if body_a_i &gt;= 0 and body_a_i == body_a_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_a_i, body_a_j, J_ia, J_ja)\n\n    # Term 2: body_a_i vs body_b_j\n    if body_a_i &gt;= 0 and body_a_i == body_b_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_a_i, body_b_j, J_ia, J_jb)\n\n    # Term 3: body_b_i vs body_a_j\n    if body_b_i &gt;= 0 and body_b_i == body_a_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_b_i, body_a_j, J_ib, J_ja)\n\n    # Term 4: body_b_i vs body_b_j\n    if body_b_i &gt;= 0 and body_b_i == body_b_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_b_i, body_b_j, J_ib, J_jb)\n\n    # Add compliance term C_ij (only on diagonal)\n    if i == j:\n        A_ij += C_values[i]\n\n    A[i, j] = A_ij\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.MatrixFreeSystemOperator","title":"<code>MatrixFreeSystemOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A matrix-free linear operator for the system A = J M\u207b\u00b9 J\u1d40 + C.</p> <p>This class provides a .matvec() method that computes the matrix-vector product A @ x without explicitly constructing the matrix A. It is intended to be used with iterative linear solvers like <code>cr_solver</code>.</p> Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>class MatrixFreeSystemOperator(LinearOperator):\n    \"\"\"\n    A matrix-free linear operator for the system A = J M\u207b\u00b9 J\u1d40 + C.\n\n    This class provides a .matvec() method that computes the matrix-vector\n    product A @ x without explicitly constructing the matrix A. It is intended\n    to be used with iterative linear solvers like `cr_solver`.\n    \"\"\"\n\n    def __init__(self, engine):\n        \"\"\"\n        Initializes the operator with data from the main physics engine.\n\n        Args:\n            engine: An instance of the main physics engine (e.g., NSNEngine)\n                    that holds all the necessary system data (Jacobians,\n                    masses, constraint info, etc.).\n        \"\"\"\n        super().__init__(\n            shape=(engine.dims.con_dim, engine.dims.con_dim),\n            dtype=wp.float32,\n            device=engine.device,\n            matvec=None,\n        ),\n        self.engine = engine\n\n        # Pre-allocate temporary buffers for intermediate calculations.\n        self._tmp_dyn_vec = wp.zeros(engine.dims.N_b, dtype=wp.spatial_vector, device=engine.device)\n        self._tmp_con_vec = wp.zeros(engine.dims.con_dim, dtype=wp.float32, device=engine.device)\n\n    def matvec(self, x, y, z, alpha, beta):\n        \"\"\"\n        Computes the matrix-vector product: z = beta * y + alpha * (A @ x).\n        \"\"\"\n        # --- Step 1: Compute v\u2081 = J\u1d40 @ x ---\n        self._tmp_dyn_vec.zero_()\n        wp.launch(\n            kernel=kernel_J_transpose_matvec,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self.engine.data.constraint_body_idx,\n                self.engine.data.J_values,\n                x,\n            ],\n            outputs=[self._tmp_dyn_vec],\n            device=self.device,\n        )\n\n        # --- Step 2: Compute v\u2082 = M\u207b\u00b9 @ v\u2081 ---\n        wp.launch(\n            kernel=kernel_inv_mass_matvec,\n            dim=self.engine.dims.N_b,\n            inputs=[\n                self.engine.data.gen_inv_mass,\n                self._tmp_dyn_vec,\n            ],\n            outputs=[self._tmp_dyn_vec],\n            device=self.device,\n        )\n\n        # --- Step 3: Compute v\u2083 = J @ v\u2082 ---\n        wp.launch(\n            kernel=kernel_J_matvec,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self.engine.data.constraint_body_idx,\n                self.engine.data.J_values,\n                self._tmp_dyn_vec,\n            ],\n            outputs=[self._tmp_con_vec],\n            device=self.device,\n        )\n\n        # --- Step 4: Compute z = beta * y + alpha * (v\u2083 + C @ x) ---\n        wp.launch(\n            kernel=kernel_finalize_matvec,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self._tmp_con_vec,  # This is J M\u207b\u00b9 J\u1d40 @ x\n                self.engine.data.C_values,\n                x,  # original x vector\n                y,  # original y vector\n                alpha,  # alpha scalar\n                beta,  # beta scalar\n                z,  # The final output vector\n            ],\n            device=self.device,\n        )\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.MatrixFreeSystemOperator.__init__","title":"<code>__init__</code>","text":"<p>Initializes the operator with data from the main physics engine.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <p>An instance of the main physics engine (e.g., NSNEngine)     that holds all the necessary system data (Jacobians,     masses, constraint info, etc.).</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>def __init__(self, engine):\n    \"\"\"\n    Initializes the operator with data from the main physics engine.\n\n    Args:\n        engine: An instance of the main physics engine (e.g., NSNEngine)\n                that holds all the necessary system data (Jacobians,\n                masses, constraint info, etc.).\n    \"\"\"\n    super().__init__(\n        shape=(engine.dims.con_dim, engine.dims.con_dim),\n        dtype=wp.float32,\n        device=engine.device,\n        matvec=None,\n    ),\n    self.engine = engine\n\n    # Pre-allocate temporary buffers for intermediate calculations.\n    self._tmp_dyn_vec = wp.zeros(engine.dims.N_b, dtype=wp.spatial_vector, device=engine.device)\n    self._tmp_con_vec = wp.zeros(engine.dims.con_dim, dtype=wp.float32, device=engine.device)\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.MatrixFreeSystemOperator.matvec","title":"<code>matvec</code>","text":"<p>Computes the matrix-vector product: z = beta * y + alpha * (A @ x).</p> Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>def matvec(self, x, y, z, alpha, beta):\n    \"\"\"\n    Computes the matrix-vector product: z = beta * y + alpha * (A @ x).\n    \"\"\"\n    # --- Step 1: Compute v\u2081 = J\u1d40 @ x ---\n    self._tmp_dyn_vec.zero_()\n    wp.launch(\n        kernel=kernel_J_transpose_matvec,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self.engine.data.constraint_body_idx,\n            self.engine.data.J_values,\n            x,\n        ],\n        outputs=[self._tmp_dyn_vec],\n        device=self.device,\n    )\n\n    # --- Step 2: Compute v\u2082 = M\u207b\u00b9 @ v\u2081 ---\n    wp.launch(\n        kernel=kernel_inv_mass_matvec,\n        dim=self.engine.dims.N_b,\n        inputs=[\n            self.engine.data.gen_inv_mass,\n            self._tmp_dyn_vec,\n        ],\n        outputs=[self._tmp_dyn_vec],\n        device=self.device,\n    )\n\n    # --- Step 3: Compute v\u2083 = J @ v\u2082 ---\n    wp.launch(\n        kernel=kernel_J_matvec,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self.engine.data.constraint_body_idx,\n            self.engine.data.J_values,\n            self._tmp_dyn_vec,\n        ],\n        outputs=[self._tmp_con_vec],\n        device=self.device,\n    )\n\n    # --- Step 4: Compute z = beta * y + alpha * (v\u2083 + C @ x) ---\n    wp.launch(\n        kernel=kernel_finalize_matvec,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self._tmp_con_vec,  # This is J M\u207b\u00b9 J\u1d40 @ x\n            self.engine.data.C_values,\n            x,  # original x vector\n            y,  # original y vector\n            alpha,  # alpha scalar\n            beta,  # beta scalar\n            z,  # The final output vector\n        ],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.kernel_J_matvec","title":"<code>kernel_J_matvec</code>","text":"<p>Computes the matrix-vector product: out_vec = J @ in_vec.</p> <p>This kernel iterates over each constraint and gathers values from the dynamics-space vector (in_vec) to produce the constraint-space vector (out_vec).</p> <p>Parameters:</p> Name Type Description Default <code>in_vec</code> <code>array(dtype=spatial_vector)</code> <p>A vector in dynamics space (e.g., M\u207b\u00b9 @ J\u1d40 @ x).</p> required <code>out_vec</code> <code>array(dtype=float32)</code> <p>The resulting vector in constraint space.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_J_matvec(\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    in_vec: wp.array(dtype=wp.spatial_vector),\n    # Output array\n    out_vec: wp.array(dtype=wp.float32),\n):\n    \"\"\"\n    Computes the matrix-vector product: out_vec = J @ in_vec.\n\n    This kernel iterates over each constraint and gathers values from the\n    dynamics-space vector (in_vec) to produce the constraint-space vector (out_vec).\n\n    Args:\n        in_vec: A vector in dynamics space (e.g., M\u207b\u00b9 @ J\u1d40 @ x).\n        out_vec: The resulting vector in constraint space.\n    \"\"\"\n    constraint_idx = wp.tid()\n\n    body_a = constraint_body_idx[constraint_idx, 0]\n    body_b = constraint_body_idx[constraint_idx, 1]\n\n    J_ia = J_values[constraint_idx, 0]\n    J_ib = J_values[constraint_idx, 1]\n\n    result = 0.0\n    if body_a &gt;= 0:\n        result += wp.dot(J_ia, in_vec[body_a])\n    if body_b &gt;= 0:\n        result += wp.dot(J_ib, in_vec[body_b])\n\n    out_vec[constraint_idx] = result\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.kernel_J_transpose_matvec","title":"<code>kernel_J_transpose_matvec</code>","text":"<p>Computes the matrix-vector product: out_vec = J\u1d40 @ vec_x.</p> <p>This kernel iterates over each constraint (the dimension of vec_x) and scatters the results into the dynamics-space vector (out_vec) using atomic adds.</p> <p>Parameters:</p> Name Type Description Default <code>vec_x</code> <code>array(dtype=float32)</code> <p>A vector in constraint space (e.g., delta_lambda).</p> required <code>out_vec</code> <code>array(dtype=spatial_vector)</code> <p>A vector in dynamics space (size num_bodies * 6) to store the result.      This vector MUST be zero-initialized before calling this kernel.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_J_transpose_matvec(\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    vec_x: wp.array(dtype=wp.float32),\n    # Output array\n    out_vec: wp.array(dtype=wp.spatial_vector),\n):\n    \"\"\"\n    Computes the matrix-vector product: out_vec = J\u1d40 @ vec_x.\n\n    This kernel iterates over each constraint (the dimension of vec_x) and\n    scatters the results into the dynamics-space vector (out_vec) using atomic adds.\n\n    Args:\n        vec_x: A vector in constraint space (e.g., delta_lambda).\n        out_vec: A vector in dynamics space (size num_bodies * 6) to store the result.\n                 This vector MUST be zero-initialized before calling this kernel.\n    \"\"\"\n    constraint_idx = wp.tid()\n\n    body_a = constraint_body_idx[constraint_idx, 0]\n    body_b = constraint_body_idx[constraint_idx, 1]\n\n    J_ia = J_values[constraint_idx, 0]\n    J_ib = J_values[constraint_idx, 1]\n    x_i = vec_x[constraint_idx]\n\n    if body_a &gt;= 0:\n        out_vec[body_a] += x_i * J_ia\n    if body_b &gt;= 0:\n        out_vec[body_b] += x_i * J_ib\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.kernel_finalize_matvec","title":"<code>kernel_finalize_matvec</code>","text":"<p>Performs the final step of the matvec computation: z = beta * y + alpha * ( (J M\u207b\u00b9 J\u1d40 @ x) + (C @ x) )</p> <p>Parameters:</p> Name Type Description Default <code>J_M_inv_Jt_x</code> <code>array(dtype=float32)</code> <p>The result of J @ M\u207b\u00b9 @ J\u1d40 @ x.</p> required <code>C_values</code> <code>array(dtype=float32)</code> <p>The diagonal entries of the compliance matrix C.</p> required <code>vec_x</code> <code>array(dtype=float32)</code> <p>The original input vector 'x' to the matvec operation.</p> required <code>vec_y</code> <code>array(dtype=float32)</code> <p>The input vector 'y'.</p> required <code>alpha</code> <code>float</code> <p>Scalar multiplier for the A@x term.</p> required <code>beta</code> <code>float</code> <p>Scalar multiplier for the y term.</p> required <code>out_vec_z</code> <code>array(dtype=float32)</code> <p>The final output vector z.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_finalize_matvec(\n    J_M_inv_Jt_x: wp.array(dtype=wp.float32),\n    C_values: wp.array(dtype=wp.float32),\n    vec_x: wp.array(dtype=wp.float32),\n    vec_y: wp.array(dtype=wp.float32),\n    alpha: float,\n    beta: float,\n    out_vec_z: wp.array(dtype=wp.float32),\n):\n    \"\"\"\n    Performs the final step of the matvec computation:\n    z = beta * y + alpha * ( (J M\u207b\u00b9 J\u1d40 @ x) + (C @ x) )\n\n    Args:\n        J_M_inv_Jt_x: The result of J @ M\u207b\u00b9 @ J\u1d40 @ x.\n        C_values: The diagonal entries of the compliance matrix C.\n        vec_x: The original input vector 'x' to the matvec operation.\n        vec_y: The input vector 'y'.\n        alpha: Scalar multiplier for the A@x term.\n        beta: Scalar multiplier for the y term.\n        out_vec_z: The final output vector z.\n    \"\"\"\n    i = wp.tid()\n    c_times_x = C_values[i] * vec_x[i]\n    a_times_x = J_M_inv_Jt_x[i] + c_times_x\n\n    # The crucial change is here: including beta * y\n    if beta == 0.0:\n        out_vec_z[i] = alpha * a_times_x\n    else:\n        out_vec_z[i] = beta * vec_y[i] + alpha * a_times_x\n</code></pre>"},{"location":"reference/axion/#axion.optim.matrixfree_operator.kernel_inv_mass_matvec","title":"<code>kernel_inv_mass_matvec</code>","text":"<p>Computes the matrix-vector product: out_vec = M\u207b\u00b9 @ in_vec.</p> <p>M\u207b\u00b9 is the block-diagonal inverse mass matrix, composed of a 3x3 inverse inertia tensor and a scalar inverse mass for each body.</p> <p>Parameters:</p> Name Type Description Default <code>in_vec</code> <code>array(dtype=spatial_vector)</code> <p>A vector in dynamics space (e.g., the result of J\u1d40 @ x).</p> required <code>out_vec</code> <code>array(dtype=spatial_vector)</code> <p>The resulting vector in dynamics space.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_inv_mass_matvec(\n    gen_inv_mass: wp.array(dtype=SpatialInertia),\n    in_vec: wp.array(dtype=wp.spatial_vector),\n    out_vec: wp.array(dtype=wp.spatial_vector),\n):\n    \"\"\"\n    Computes the matrix-vector product: out_vec = M\u207b\u00b9 @ in_vec.\n\n    M\u207b\u00b9 is the block-diagonal inverse mass matrix, composed of a 3x3 inverse\n    inertia tensor and a scalar inverse mass for each body.\n\n    Args:\n        in_vec: A vector in dynamics space (e.g., the result of J\u1d40 @ x).\n        out_vec: The resulting vector in dynamics space.\n    \"\"\"\n    body_idx = wp.tid()\n\n    out_vec[body_idx] = to_spatial_momentum(gen_inv_mass[body_idx], in_vec[body_idx])\n</code></pre>"},{"location":"reference/axion/#axion.optim.preconditioner.JacobiPreconditioner","title":"<code>JacobiPreconditioner</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A Jacobi (diagonal) preconditioner for the system matrix A = J M\u207b\u00b9 J\u1d40 + C.</p> <p>This class provides a .matvec() method that applies the inverse of the diagonal of A, for use with Warp's iterative solvers.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>class JacobiPreconditioner(LinearOperator):\n    \"\"\"\n    A Jacobi (diagonal) preconditioner for the system matrix A = J M\u207b\u00b9 J\u1d40 + C.\n\n    This class provides a .matvec() method that applies the inverse of the\n    diagonal of A, for use with Warp's iterative solvers.\n    \"\"\"\n\n    def __init__(self, engine):\n        super().__init__(\n            shape=(engine.dims.con_dim, engine.dims.con_dim),\n            dtype=wp.float32,\n            device=engine.device,\n            matvec=None,  # Will be set later\n        )\n        self.engine = engine\n\n        # Storage for the inverse diagonal elements\n        self._P_inv_diag = wp.zeros(engine.dims.con_dim, dtype=wp.float32, device=self.device)\n\n    def update(self):\n        \"\"\"\n        Re-computes the preconditioner's data. This must be called each time\n        the Jacobian (J) or compliance (C) values change.\n        \"\"\"\n        wp.launch(\n            kernel=compute_inv_diag_kernel,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self.engine.data.constraint_body_idx,\n                self.engine.data.gen_inv_mass,\n                self.engine.data.J_values,\n                self.engine.data.C_values,\n            ],\n            outputs=[self._P_inv_diag],\n            device=self.device,\n        )\n\n    def matvec(self, x, y, z, alpha, beta):\n        \"\"\"\n        Performs the preconditioning operation z = beta*y + alpha*(M\u207b\u00b9@x),\n        where M\u207b\u00b9 is the inverse diagonal matrix stored in `_P_inv_diag`.\n        \"\"\"\n        wp.launch(\n            kernel=apply_preconditioner_kernel,\n            dim=self.engine.dims.con_dim,\n            inputs=[self._P_inv_diag, x, y, alpha, beta, z],\n            device=self.device,\n        )\n</code></pre>"},{"location":"reference/axion/#axion.optim.preconditioner.JacobiPreconditioner.matvec","title":"<code>matvec</code>","text":"<p>Performs the preconditioning operation z = betay + alpha(M\u207b\u00b9@x), where M\u207b\u00b9 is the inverse diagonal matrix stored in <code>_P_inv_diag</code>.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>def matvec(self, x, y, z, alpha, beta):\n    \"\"\"\n    Performs the preconditioning operation z = beta*y + alpha*(M\u207b\u00b9@x),\n    where M\u207b\u00b9 is the inverse diagonal matrix stored in `_P_inv_diag`.\n    \"\"\"\n    wp.launch(\n        kernel=apply_preconditioner_kernel,\n        dim=self.engine.dims.con_dim,\n        inputs=[self._P_inv_diag, x, y, alpha, beta, z],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/#axion.optim.preconditioner.JacobiPreconditioner.update","title":"<code>update</code>","text":"<p>Re-computes the preconditioner's data. This must be called each time the Jacobian (J) or compliance (C) values change.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>def update(self):\n    \"\"\"\n    Re-computes the preconditioner's data. This must be called each time\n    the Jacobian (J) or compliance (C) values change.\n    \"\"\"\n    wp.launch(\n        kernel=compute_inv_diag_kernel,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self.engine.data.constraint_body_idx,\n            self.engine.data.gen_inv_mass,\n            self.engine.data.J_values,\n            self.engine.data.C_values,\n        ],\n        outputs=[self._P_inv_diag],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/#axion.optim.preconditioner.apply_preconditioner_kernel","title":"<code>apply_preconditioner_kernel</code>","text":"<p>Applies the Jacobi preconditioner: z = beta*y + alpha * P\u207b\u00b9 * x</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>@wp.kernel\ndef apply_preconditioner_kernel(\n    P_inv_diag: wp.array(dtype=wp.float32),\n    vec_x: wp.array(dtype=wp.float32),\n    vec_y: wp.array(dtype=wp.float32),\n    alpha: float,\n    beta: float,\n    out_vec_z: wp.array(dtype=wp.float32),\n):\n    \"\"\"Applies the Jacobi preconditioner: z = beta*y + alpha * P\u207b\u00b9 * x\"\"\"\n    i = wp.tid()\n    preconditioned_x = P_inv_diag[i] * vec_x[i]\n\n    if beta == 0.0:\n        out_vec_z[i] = alpha * preconditioned_x\n    else:\n        out_vec_z[i] = beta * vec_y[i] + alpha * preconditioned_x\n</code></pre>"},{"location":"reference/axion/#axion.optim.preconditioner.compute_inv_diag_kernel","title":"<code>compute_inv_diag_kernel</code>","text":"<p>Computes the inverse of the diagonal of the system matrix A = J M\u207b\u00b9 J\u1d40 + C. The result P_inv_diag[i] = 1.0 / A[i,i] is stored.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>@wp.kernel\ndef compute_inv_diag_kernel(\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    gen_inv_mass: wp.array(dtype=SpatialInertia),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    C_values: wp.array(dtype=wp.float32),\n    # Output array\n    P_inv_diag: wp.array(dtype=wp.float32),\n):\n    \"\"\"\n    Computes the inverse of the diagonal of the system matrix A = J M\u207b\u00b9 J\u1d40 + C.\n    The result P_inv_diag[i] = 1.0 / A[i,i] is stored.\n    \"\"\"\n    constraint_idx = wp.tid()\n\n    body_a = constraint_body_idx[constraint_idx, 0]\n    body_b = constraint_body_idx[constraint_idx, 1]\n\n    result = 0.0\n    if body_a &gt;= 0:\n        Minv_a = gen_inv_mass[body_a]\n        J_ia = J_values[constraint_idx, 0]\n        result += wp.dot(J_ia, to_spatial_momentum(Minv_a, J_ia))\n    if body_b &gt;= 0:\n        Minv_b = gen_inv_mass[body_b]\n        J_ib = J_values[constraint_idx, 1]\n        result += wp.dot(J_ib, to_spatial_momentum(Minv_b, J_ib))\n\n    # Add diagonal compliance term C[i,i]\n    diag_A = result + C_values[constraint_idx]\n\n    # Compute and store inverse, with stabilization\n    P_inv_diag[constraint_idx] = 1.0 / (diag_A + 1e-6)\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/","title":"abstract_simulator","text":"<p>An abstract base class for running a Warp-based physics simulation.</p>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.AbstractSimulator","title":"<code>AbstractSimulator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class for running a Warp-based physics simulation.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>class AbstractSimulator(ABC):\n    \"\"\"An abstract base class for running a Warp-based physics simulation.\"\"\"\n\n    def __init__(\n        self,\n        simulation_config: SimulationConfig,\n        rendering_config: RenderingConfig,\n        execution_config: ExecutionConfig,\n        profiling_config: ProfilingConfig,\n        engine_config: EngineConfig,\n    ):\n        self.simulation_config = simulation_config\n        self.rendering_config = rendering_config\n        self.execution_config = execution_config\n        self.profiling_config = profiling_config\n        self.engine_config = engine_config\n\n        self.logger = (\n            HDF5Logger(self.profiling_config.hdf5_log_file)\n            if self.profiling_config.enable_hdf5_logging\n            else NullLogger()\n        )\n\n        self._current_step = 0\n        self._current_time = 0.0\n\n        # Calculated by _resolve_timing_parameters\n        self.steps_per_segment: int = 0\n        self.num_segments: int = 0\n        self.effective_timestep: float = 0.0\n        self.effective_duration: float = 0.0\n        self._resolve_timing_parameters()\n\n        self.model = self.build_model()\n\n        self.current_state = self.model.state()\n        self.next_state = self.model.state()\n        self.control = self.model.control()\n\n        if isinstance(self.engine_config, AxionEngineConfig):\n            self.integrator = AxionEngine(self.model, self.engine_config, self.logger)\n        elif isinstance(self.engine_config, FeatherstoneEngineConfig):\n            self.integrator = wp.sim.FeatherstoneIntegrator(self.model, **vars(self.engine_config))\n            wp.sim.eval_fk(\n                self.model, self.model.joint_q, self.model.joint_qd, None, self.current_state\n            )\n        elif isinstance(self.engine_config, SemiImplicitEngineConfig):\n            self.integrator = wp.sim.SemiImplicitIntegrator(**vars(self.engine_config))\n        elif isinstance(self.engine_config, XPBDEngineConfig):\n            self.integrator = wp.sim.XPBDIntegrator(**vars(self.engine_config))\n        else:\n            raise ValueError(f\"Unsupported engine configuration type: {type(self.engine_config)}\")\n\n        self.renderer: Optional[wp.sim.render.SimRenderer] = None\n        if self.rendering_config.enable:\n            self.renderer = wp.sim.render.SimRenderer(\n                self.model,\n                self.rendering_config.usd_file,\n                scaling=self.rendering_config.scaling,\n                fps=self.rendering_config.fps,\n            )\n\n        self.cuda_graph: Optional[wp.Graph] = None\n\n        num_substeps = self.steps_per_segment\n        self.start_events = [wp.Event(enable_timing=True) for _ in range(num_substeps)]\n        self.collision_events = [wp.Event(enable_timing=True) for _ in range(num_substeps)]\n        self.integration_events = [wp.Event(enable_timing=True) for _ in range(num_substeps)]\n\n        self.events = [\n            {\n                \"step_start\": wp.Event(enable_timing=True),\n                \"collision\": wp.Event(enable_timing=True),\n                \"integration\": wp.Event(enable_timing=True),\n                \"integration_parts\": None,\n            }\n            for _ in range(num_substeps)\n        ]\n\n        self.simulation_events = [[] for _ in range(num_substeps)]\n\n    def run(self):\n        \"\"\"Main entry point to start the simulation.\"\"\"\n        disable_progress = self.profiling_config.enable_timing\n        with self.logger:\n            for i in tqdm(\n                range(self.num_segments),\n                desc=\"Simulating\",\n                disable=disable_progress,\n            ):\n                self._run_simulation_segment(i)\n\n                if self.rendering_config.enable:\n                    wp.synchronize()\n                    time = (i + 1) * (1.0 / self.rendering_config.fps)\n                    self.renderer.begin_frame(time)\n                    self.renderer.render(self.current_state)\n                    self.renderer.end_frame()\n\n        if self.rendering_config.enable:\n            self.renderer.save()\n            print(f\"Rendering complete. Output saved to {self.rendering_config.usd_file}\")\n        else:\n            wp.synchronize()\n            print(\"Headless simulation complete.\")\n\n    def _run_simulation_segment(self, segment_num: int):\n        \"\"\"Executes a single simulation segment, using the chosen execution path.\"\"\"\n        if self.use_cuda_graph:\n            self._run_segment_with_graph(segment_num)\n        else:\n            self._run_segment_without_graph(segment_num)\n\n    def _run_segment_without_graph(self, segment_num: int):\n        \"\"\"Runs a segment by iterating and launching each step's kernels individually.\"\"\"\n        n_steps = self.steps_per_segment\n        timer_msg = f\"SEGMENT {segment_num}/{self.num_segments}: Simulation of {n_steps} time steps\"\n        with wp.ScopedTimer(\n            timer_msg,\n            active=self.profiling_config.enable_timing,\n            synchronize=True,\n        ):\n            for step in range(n_steps):\n                self._single_physics_step(step)\n\n                # Update attributes for logging\n                self._current_step += 1\n                self._current_time += self.effective_timestep\n\n        if self.profiling_config.enable_timing:\n            self._log_segment_timings()\n\n    def _run_segment_with_graph(self, segment_num: int):\n        \"\"\"Runs a segment by launching a pre-captured CUDA graph.\"\"\"\n        if self.cuda_graph is None:\n            self._capture_cuda_graph()\n\n        n_steps = self.steps_per_segment\n        timer_msg = f\"SEGMENT {segment_num}/{self.num_segments}: Simulation of {n_steps} time steps (with CUDA graph)\"\n        with wp.ScopedTimer(\n            timer_msg,\n            active=self.profiling_config.enable_timing,\n            synchronize=True,\n        ):\n            wp.capture_launch(self.cuda_graph)\n\n        if self.profiling_config.enable_timing:\n            self._log_segment_timings()\n\n    def _log_segment_timings(self):\n        \"\"\"Logs the detailed timing information for the most recent segment.\"\"\"\n        for step in range(self.steps_per_segment):\n            collision_time = wp.get_event_elapsed_time(\n                self.events[step][\"step_start\"],\n                self.events[step][\"collision\"],\n            )\n            integration_time = wp.get_event_elapsed_time(\n                self.events[step][\"collision\"],\n                self.events[step][\"integration\"],\n            )\n\n            print(\n                f\"\\t- SUBSTEP {step}: collision detection took {collision_time:.03f} ms \"\n                f\"and simulation step took {integration_time:0.3f} ms.\"\n            )\n\n            # Check if detailed integrator events were captured\n            if self.events[step][\"integration_parts\"] is None:\n                continue\n\n            for newton_iter in range(self.engine_config.newton_iters):\n                events = self.events[step][\"integration_parts\"][newton_iter]\n                linearize_time = wp.get_event_elapsed_time(\n                    events[\"iter_start\"], events[\"linearize\"]\n                )\n                lin_solve_time = wp.get_event_elapsed_time(events[\"linearize\"], events[\"lin_solve\"])\n                linesearch_time = wp.get_event_elapsed_time(\n                    events[\"lin_solve\"], events[\"linesearch\"]\n                )\n\n                print(\n                    f\"\\t\\t- NEWTON ITERATION {newton_iter}: Linearization took {linearize_time:.03f} ms, \"\n                    f\"solving of linear system took {lin_solve_time:.03f} ms and linesearch took {linesearch_time:.03f} ms.\"\n                )\n\n    def _capture_cuda_graph(self):\n        \"\"\"Records the sequence of operations for one segment into a CUDA graph.\"\"\"\n        n_steps = self.steps_per_segment\n        with wp.ScopedCapture() as capture:\n            for i in range(n_steps):\n                self._single_physics_step(i)\n        self.cuda_graph = capture.graph\n\n    def _single_physics_step(self, step_num: int):\n        \"\"\"Performs one fundamental integration step of the simulation.\"\"\"\n        with self.logger.scope(f\"timestep_{self._current_step:04d}\"):\n            self.logger.log_scalar(\"time\", self._current_time)\n\n            # Record that step started\n            wp.record_event(self.events[step_num][\"step_start\"])\n\n            # Detect collisions\n            wp.sim.collide(self.model, self.current_state)\n\n            # Record that collision detection finished\n            wp.record_event(self.events[step_num][\"collision\"])\n            self.logger.log_wp_dataset(\"rigid_contact_count\", self.model.rigid_contact_count)\n\n            # Compute simulation step\n            self.events[step_num][\"integration_parts\"] = self.integrator.simulate(\n                model=self.model,\n                state_in=self.current_state,\n                state_out=self.next_state,\n                dt=self.effective_timestep,\n                control=self.control,\n            )\n\n            # Record that simulation step finished\n            wp.record_event(self.events[step_num][\"integration\"])\n\n            wp.copy(dest=self.current_state.body_q, src=self.next_state.body_q)\n            wp.copy(dest=self.current_state.body_qd, src=self.next_state.body_qd)\n\n    def _resolve_timing_parameters(self):\n        \"\"\"\n        Calculates all operational timing parameters based on user configuration,\n        ensuring alignment between simulation, rendering, and segmentation.\n        \"\"\"\n        if self.rendering_config.enable:\n            self.effective_timestep, self.steps_per_segment = calculate_render_aligned_timestep(\n                self.simulation_config.target_timestep_seconds, self.rendering_config.fps\n            )\n        else:\n            self.effective_timestep = self.simulation_config.target_timestep_seconds\n            self.steps_per_segment = self.execution_config.headless_steps_per_segment\n\n        self.effective_duration, self.num_segments = align_duration_to_segment(\n            self.simulation_config.duration_seconds, self.effective_timestep, self.steps_per_segment\n        )\n\n    @property\n    def use_cuda_graph(self) -&gt; bool:\n        \"\"\"Determines if conditions are met to use CUDA graph optimization.\"\"\"\n        return (\n            self.execution_config.use_cuda_graph\n            and wp.get_device().is_cuda\n            and not self.profiling_config.enable_hdf5_logging\n        )\n\n    @abstractmethod\n    def build_model(self) -&gt; wp.sim.Model:\n        \"\"\"\n        Builds the physics model for the simulation.\n\n        This method MUST be implemented by any subclass. It should define all the\n        rigid bodies, joints, and other physical properties of the scene.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.AbstractSimulator.use_cuda_graph","title":"<code>use_cuda_graph</code>  <code>property</code>","text":"<p>Determines if conditions are met to use CUDA graph optimization.</p>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.AbstractSimulator.build_model","title":"<code>build_model</code>  <code>abstractmethod</code>","text":"<p>Builds the physics model for the simulation.</p> <p>This method MUST be implemented by any subclass. It should define all the rigid bodies, joints, and other physical properties of the scene.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@abstractmethod\ndef build_model(self) -&gt; wp.sim.Model:\n    \"\"\"\n    Builds the physics model for the simulation.\n\n    This method MUST be implemented by any subclass. It should define all the\n    rigid bodies, joints, and other physical properties of the scene.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.AbstractSimulator.run","title":"<code>run</code>","text":"<p>Main entry point to start the simulation.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>def run(self):\n    \"\"\"Main entry point to start the simulation.\"\"\"\n    disable_progress = self.profiling_config.enable_timing\n    with self.logger:\n        for i in tqdm(\n            range(self.num_segments),\n            desc=\"Simulating\",\n            disable=disable_progress,\n        ):\n            self._run_simulation_segment(i)\n\n            if self.rendering_config.enable:\n                wp.synchronize()\n                time = (i + 1) * (1.0 / self.rendering_config.fps)\n                self.renderer.begin_frame(time)\n                self.renderer.render(self.current_state)\n                self.renderer.end_frame()\n\n    if self.rendering_config.enable:\n        self.renderer.save()\n        print(f\"Rendering complete. Output saved to {self.rendering_config.usd_file}\")\n    else:\n        wp.synchronize()\n        print(\"Headless simulation complete.\")\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.ExecutionConfig","title":"<code>ExecutionConfig</code>  <code>dataclass</code>","text":"<p>Parameters controlling the performance and execution strategy.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass ExecutionConfig:\n    \"\"\"Parameters controlling the performance and execution strategy.\"\"\"\n\n    use_cuda_graph: bool = True\n    headless_steps_per_segment: int = 10\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.ProfilingConfig","title":"<code>ProfilingConfig</code>  <code>dataclass</code>","text":"<p>Parameters for debugging, timing, and logging.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass ProfilingConfig:\n    \"\"\"Parameters for debugging, timing, and logging.\"\"\"\n\n    enable_timing: bool = False\n\n    # Enables HDF5 logging (disables CUDA graph optimization).\n    enable_hdf5_logging: bool = False\n    hdf5_log_file: str = \"simulation.h5\"\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.RenderingConfig","title":"<code>RenderingConfig</code>  <code>dataclass</code>","text":"<p>Parameters for rendering the simulation to a USD file.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass RenderingConfig:\n    \"\"\"Parameters for rendering the simulation to a USD file.\"\"\"\n\n    enable: bool = True\n    fps: int = 30\n    scaling: float = 100.0\n    usd_file: str = \"sim.usd\"\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.SimulationConfig","title":"<code>SimulationConfig</code>  <code>dataclass</code>","text":"<p>Parameters defining the simulation's timeline.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>@dataclass\nclass SimulationConfig:\n    \"\"\"Parameters defining the simulation's timeline.\"\"\"\n\n    duration_seconds: float = 3.0\n    target_timestep_seconds: float = 1e-3\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.align_duration_to_segment","title":"<code>align_duration_to_segment</code>","text":"<p>Adjusts total simulation duration to be a whole multiple of the segment duration.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>def align_duration_to_segment(target_duration: float, timestep: float, steps_per_segment: int):\n    \"\"\"Adjusts total simulation duration to be a whole multiple of the segment duration.\"\"\"\n    segment_duration = timestep * steps_per_segment\n    num_segments = math.ceil(target_duration / segment_duration)\n    total_sim_steps = num_segments * steps_per_segment\n    effective_duration = total_sim_steps * timestep\n\n    adj_ratio = abs(effective_duration - target_duration) / target_duration\n    if adj_ratio &gt; 0.01:\n        print(\n            f\"\\nINFO: Simulation duration adjusted to {effective_duration:.4f}s \"\n            f\"to align with segment size. ({100 * adj_ratio:.3}% change)\"\n        )\n    return effective_duration, num_segments\n</code></pre>"},{"location":"reference/axion/core/abstract_simulator/#axion.core.abstract_simulator.calculate_render_aligned_timestep","title":"<code>calculate_render_aligned_timestep</code>","text":"<p>Calculates an effective timestep that aligns perfectly with render frame duration.</p> Source code in <code>src/axion/core/abstract_simulator.py</code> <pre><code>def calculate_render_aligned_timestep(target_timestep_seconds: float, fps: int):\n    \"\"\"Calculates an effective timestep that aligns perfectly with render frame duration.\"\"\"\n    frame_duration = 1.0 / fps\n    ideal_steps_per_frame = frame_duration / target_timestep_seconds\n    steps_per_frame = round(ideal_steps_per_frame) or 1\n    effective_timestep = frame_duration / steps_per_frame\n\n    adj_ratio = abs(effective_timestep - target_timestep_seconds) / target_timestep_seconds\n    if adj_ratio &gt; 0.01:\n        print(\n            f\"\\nINFO: Target timestep adjusted to {1000 * effective_timestep:.3f}ms\"\n            f\" for rendering. ({100 * adj_ratio:.3}% change)\"\n        )\n\n    return effective_timestep, steps_per_frame\n</code></pre>"},{"location":"reference/axion/core/engine/","title":"engine","text":"<p>Axion physics engine implementation using Warp.</p>"},{"location":"reference/axion/core/engine/#axion.core.engine.AxionEngine","title":"<code>AxionEngine</code>","text":"<p>               Bases: <code>Integrator</code></p> <p>The class implements a low-level physics solver. The engine implements a Non-Smooth Newton Method to solve the entire physics state\u2014including dynamics, contacts, and joints\u2014as a single, unified problem at each time step. This monolithic approach provides exceptional stability, especially for complex, highly-constrained systems like articulated robots.</p> Source code in <code>src/axion/core/engine.py</code> <pre><code>class AxionEngine(Integrator):\n    \"\"\"\n    The class implements a low-level physics solver.\n    The engine implements a Non-Smooth Newton Method to solve\n    the entire physics state\u2014including dynamics, contacts,\n    and joints\u2014as a single, unified problem at each time step.\n    This monolithic approach provides exceptional stability,\n    especially for complex, highly-constrained systems like\n    articulated robots.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: Model,\n        config: Optional[AxionEngineConfig],\n        logger: Optional[HDF5Logger | NullLogger],\n    ):\n        \"\"\"\n        Initialize the physics engine for the given model and configuration.\n\n        Args:\n            model: The warp.sim.Model physics model containing bodies, joints, and other physics properties.\n            config: Configuration parameters for the engine of type EngineConfig.\n            logger: Optional HDF5Logger or NullLogger for recording simulation data.\n        \"\"\"\n        super().__init__()\n        self.device = model.device\n\n        self.model = model\n        self.logger = logger\n        self.config = config\n\n        self.dims = EngineDimensions(\n            N_b=self.model.body_count,\n            N_c=self.model.rigid_contact_max,\n            N_j=self.model.joint_count,\n            N_alpha=self.config.linesearch_steps,\n        )\n\n        allocate_dense_matrices = isinstance(self.logger, HDF5Logger)\n        self.data = create_engine_arrays(self.dims, self.device, allocate_dense_matrices)\n\n        if self.config.matrixfree_representation:\n            self.A_op = MatrixFreeSystemOperator(self)\n        else:\n            self.A_op = MatrixSystemOperator(self)\n\n        self.preconditioner = JacobiPreconditioner(self)\n\n        self.data.set_generalized_mass(model)\n        self.data.set_gravitational_acceleration(model)\n\n        self.events = [\n            {\n                \"iter_start\": wp.Event(enable_timing=True),\n                \"linearize\": wp.Event(enable_timing=True),\n                \"lin_solve\": wp.Event(enable_timing=True),\n                \"linesearch\": wp.Event(enable_timing=True),\n            }\n            for _ in range(self.config.newton_iters)\n        ]\n\n    def _log_newton_iteration_data(self):\n        if isinstance(self.logger, NullLogger):\n            return\n\n        self.logger.log_wp_dataset(\"res\", self.data.res)\n        self.logger.log_wp_dataset(\"J_values\", self.data.J_values)\n        self.logger.log_wp_dataset(\"C_values\", self.data.C_values)\n        self.logger.log_wp_dataset(\"constraint_body_idx\", self.data.constraint_body_idx)\n\n        self.logger.log_wp_dataset(\"body_f\", self.data.body_f)\n        self.logger.log_wp_dataset(\"body_q\", self.data.body_q)\n        self.logger.log_wp_dataset(\"body_qd\", self.data.body_qd)\n        self.logger.log_wp_dataset(\"body_qd_prev\", self.data.body_qd_prev)\n\n        self.logger.log_wp_dataset(\"lambda\", self.data._lambda)\n        self.logger.log_wp_dataset(\"lambda_prev\", self.data.lambda_prev)\n\n        self.logger.log_wp_dataset(\"delta_body_qd\", self.data.delta_body_qd)\n        self.logger.log_wp_dataset(\"delta_lambda\", self.data.delta_lambda)\n\n        self.logger.log_wp_dataset(\"b\", self.data.b)\n\n        self.logger.log_struct_array(\"gen_mass\", self.data.gen_mass)\n        self.logger.log_struct_array(\"gen_inv_mass\", self.data.gen_inv_mass)\n\n        self.logger.log_struct_array(\"joint_interaction\", self.data.joint_interaction)\n        self.logger.log_struct_array(\"contact_interaction\", self.data.contact_interaction)\n\n        update_dense_matrices(self.data, self.config, self.dims)\n\n        self.logger.log_wp_dataset(\"Minv_dense\", self.data.Minv_dense)\n        self.logger.log_wp_dataset(\"J_dense\", self.data.J_dense)\n        self.logger.log_wp_dataset(\"C_dense\", self.data.C_dense)\n\n        if not self.config.matrixfree_representation:\n            self.logger.log_wp_dataset(\"A_dense\", self.A_op._A)\n        else:\n            A_np = get_system_matrix_numpy(self.data, self.config, self.dims)\n            cond_number = np.linalg.cond(A_np)\n            self.logger.log_np_dataset(\"A_np\", A_np)\n            self.logger.log_scalar(\"cond_number\", cond_number)\n\n    def _log_static_data(self):\n        if isinstance(self.logger, NullLogger):\n            return\n\n        self.logger.log_wp_dataset(\"gen_mass\", self.data.gen_mass)\n        self.logger.log_wp_dataset(\"gen_inv_mass\", self.data.gen_inv_mass)\n\n    def simulate(\n        self,\n        model: Model,\n        state_in: State,\n        state_out: State,\n        dt: float,\n        control: Control | None = None,\n    ):\n        \"\"\"\n        The primary method for running the physics simulation for a single time step.\n        This method is an implementation of the abstract method from the base `Integrator` class in Warp.\n\n        Args:\n            model: The physics model containing bodies, joints, and other physics properties.\n            state_in: The input state at the beginning of the time step.\n            state_out: The output state at the end of the time step. This will be modified by the engine.\n            dt: The time step duration.\n            control: Optional control inputs to be applied during the simulation step.\n        \"\"\"\n        apply_control(model, state_in, state_out, dt, control)\n        self.integrate_bodies(model, state_in, state_out, dt)\n        self.data.update_state_data(model, state_in, state_out)\n\n        # TODO: Check the warm startup\n        # self._lambda.zero_()\n\n        for i in range(self.config.newton_iters):\n            wp.record_event(self.events[i][\"iter_start\"])\n\n            with self.logger.scope(f\"newton_iteration_{i:02d}\"):\n                wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n                wp.copy(dest=self.data.lambda_n_scale_prev, src=self.data.lambda_n_scale)\n\n                # --- Linearize the system of equations ---\n                compute_linear_system(self.model, self.data, self.config, self.dims, dt)\n                wp.record_event(self.events[i][\"linearize\"])\n\n                if not self.config.matrixfree_representation:\n                    self.A_op.update()\n                self.preconditioner.update()\n\n                # --- Solve linear system of equations ---\n                cr_solver(\n                    A=self.A_op,\n                    b=self.data.b,\n                    x=self.data.delta_lambda,\n                    iters=self.config.linear_iters,\n                    preconditioner=self.preconditioner,\n                    logger=self.logger,\n                )\n\n                compute_delta_body_qd_from_delta_lambda(self.data, self.config, self.dims)\n                wp.record_event(self.events[i][\"lin_solve\"])\n\n                if self.config.linesearch_steps &gt; 0:\n                    perform_linesearch(self.data, self.config, self.dims, dt)\n                wp.record_event(self.events[i][\"linesearch\"])\n\n                update_variables(self.model, self.data, self.config, self.dims, dt)\n\n                self._log_newton_iteration_data()\n\n        update_body_q(self.model, self.data, self.config, self.dims, dt)\n        wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n        wp.copy(dest=state_out.body_q, src=self.data.body_q)\n\n        return self.events\n\n    def simulate_scipy(\n        self,\n        model: Model,\n        state_in: State,\n        state_out: State,\n        dt: float,\n        control: Control | None = None,\n        method: str = \"hybr\",\n        tolerance: float = 1e-10,\n        max_iterations: int = 5000,\n    ):\n        \"\"\"\n        Apply the SciPy root-finding algorithm to the simulation.\n\n        Args:\n            model: The physics model containing bodies, joints, and other physics properties.\n            state_in: The input state at the beginning of the time step.\n            state_out: The output state at the end of the time step. This will be modified by the engine.\n            dt: The time step duration.\n            control: Optional control inputs to be applied during the simulation step.\n            method: The scipy root-finding method to use (default is 'hybr').\n            tolerance: The tolerance for convergence (default is 1e-10).\n            max_iterations: The maximum number of iterations for the solver (default is 5000).\n        \"\"\"\n        apply_control(model, state_in, state_out, dt, control)\n        self.integrate_bodies(model, state_in, state_out, dt)\n        self.data.update_state_data(model, state_in, state_out)\n\n        def residual_function(x: np.ndarray) -&gt; np.ndarray:\n            wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n\n            # x contains both lambda and body_qd\n            n_lambda = self.dims.con_dim\n            lambda_vals = x[:n_lambda]\n            body_qd_vals = x[n_lambda:]\n\n            # Store current state\n            lambda_backup = wp.clone(self.data._lambda)\n            body_qd_backup = wp.clone(self.data.body_qd)\n\n            try:\n                # Set state from input vector\n                self.data._lambda.assign(lambda_vals)\n                self.data.body_qd.assign(body_qd_vals)\n\n                # Compute residuals (right hand side of the linear system)\n                compute_linear_system(self.data, self.config, self.dims, dt)\n\n                # Residual is concatenation of g and h vector\n                return self.data.res.numpy()\n\n            finally:\n                # Restore original state\n                wp.copy(dest=self.data._lambda, src=lambda_backup)\n                wp.copy(dest=self.data.body_qd, src=body_qd_backup)\n\n        # Initial guess from current state\n        x0 = np.concatenate([self.data._lambda.numpy(), self.data.body_qd.numpy().flatten()])\n\n        # Solve\n        result = scipy.optimize.root(\n            residual_function,\n            x0,\n            method=method,\n            options={\"xtol\": tolerance, \"maxfev\": max_iterations},\n        )\n\n        n_lambda = self.dims.con_dim\n        self.data._lambda.assign(wp.from_numpy(result.x[:n_lambda].astype(np.float32)))\n        body_qd_solution = result.x[n_lambda:][np.newaxis, :]\n        self.data.body_qd.assign(wp.from_numpy(body_qd_solution.astype(np.float32)))\n\n        wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n        wp.copy(dest=state_out.body_q, src=self.data.body_q)\n</code></pre>"},{"location":"reference/axion/core/engine/#axion.core.engine.AxionEngine.__init__","title":"<code>__init__</code>","text":"<p>Initialize the physics engine for the given model and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The warp.sim.Model physics model containing bodies, joints, and other physics properties.</p> required <code>config</code> <code>Optional[AxionEngineConfig]</code> <p>Configuration parameters for the engine of type EngineConfig.</p> required <code>logger</code> <code>Optional[HDF5Logger | NullLogger]</code> <p>Optional HDF5Logger or NullLogger for recording simulation data.</p> required Source code in <code>src/axion/core/engine.py</code> <pre><code>def __init__(\n    self,\n    model: Model,\n    config: Optional[AxionEngineConfig],\n    logger: Optional[HDF5Logger | NullLogger],\n):\n    \"\"\"\n    Initialize the physics engine for the given model and configuration.\n\n    Args:\n        model: The warp.sim.Model physics model containing bodies, joints, and other physics properties.\n        config: Configuration parameters for the engine of type EngineConfig.\n        logger: Optional HDF5Logger or NullLogger for recording simulation data.\n    \"\"\"\n    super().__init__()\n    self.device = model.device\n\n    self.model = model\n    self.logger = logger\n    self.config = config\n\n    self.dims = EngineDimensions(\n        N_b=self.model.body_count,\n        N_c=self.model.rigid_contact_max,\n        N_j=self.model.joint_count,\n        N_alpha=self.config.linesearch_steps,\n    )\n\n    allocate_dense_matrices = isinstance(self.logger, HDF5Logger)\n    self.data = create_engine_arrays(self.dims, self.device, allocate_dense_matrices)\n\n    if self.config.matrixfree_representation:\n        self.A_op = MatrixFreeSystemOperator(self)\n    else:\n        self.A_op = MatrixSystemOperator(self)\n\n    self.preconditioner = JacobiPreconditioner(self)\n\n    self.data.set_generalized_mass(model)\n    self.data.set_gravitational_acceleration(model)\n\n    self.events = [\n        {\n            \"iter_start\": wp.Event(enable_timing=True),\n            \"linearize\": wp.Event(enable_timing=True),\n            \"lin_solve\": wp.Event(enable_timing=True),\n            \"linesearch\": wp.Event(enable_timing=True),\n        }\n        for _ in range(self.config.newton_iters)\n    ]\n</code></pre>"},{"location":"reference/axion/core/engine/#axion.core.engine.AxionEngine.simulate","title":"<code>simulate</code>","text":"<p>The primary method for running the physics simulation for a single time step. This method is an implementation of the abstract method from the base <code>Integrator</code> class in Warp.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The physics model containing bodies, joints, and other physics properties.</p> required <code>state_in</code> <code>State</code> <p>The input state at the beginning of the time step.</p> required <code>state_out</code> <code>State</code> <p>The output state at the end of the time step. This will be modified by the engine.</p> required <code>dt</code> <code>float</code> <p>The time step duration.</p> required <code>control</code> <code>Control | None</code> <p>Optional control inputs to be applied during the simulation step.</p> <code>None</code> Source code in <code>src/axion/core/engine.py</code> <pre><code>def simulate(\n    self,\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    control: Control | None = None,\n):\n    \"\"\"\n    The primary method for running the physics simulation for a single time step.\n    This method is an implementation of the abstract method from the base `Integrator` class in Warp.\n\n    Args:\n        model: The physics model containing bodies, joints, and other physics properties.\n        state_in: The input state at the beginning of the time step.\n        state_out: The output state at the end of the time step. This will be modified by the engine.\n        dt: The time step duration.\n        control: Optional control inputs to be applied during the simulation step.\n    \"\"\"\n    apply_control(model, state_in, state_out, dt, control)\n    self.integrate_bodies(model, state_in, state_out, dt)\n    self.data.update_state_data(model, state_in, state_out)\n\n    # TODO: Check the warm startup\n    # self._lambda.zero_()\n\n    for i in range(self.config.newton_iters):\n        wp.record_event(self.events[i][\"iter_start\"])\n\n        with self.logger.scope(f\"newton_iteration_{i:02d}\"):\n            wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n            wp.copy(dest=self.data.lambda_n_scale_prev, src=self.data.lambda_n_scale)\n\n            # --- Linearize the system of equations ---\n            compute_linear_system(self.model, self.data, self.config, self.dims, dt)\n            wp.record_event(self.events[i][\"linearize\"])\n\n            if not self.config.matrixfree_representation:\n                self.A_op.update()\n            self.preconditioner.update()\n\n            # --- Solve linear system of equations ---\n            cr_solver(\n                A=self.A_op,\n                b=self.data.b,\n                x=self.data.delta_lambda,\n                iters=self.config.linear_iters,\n                preconditioner=self.preconditioner,\n                logger=self.logger,\n            )\n\n            compute_delta_body_qd_from_delta_lambda(self.data, self.config, self.dims)\n            wp.record_event(self.events[i][\"lin_solve\"])\n\n            if self.config.linesearch_steps &gt; 0:\n                perform_linesearch(self.data, self.config, self.dims, dt)\n            wp.record_event(self.events[i][\"linesearch\"])\n\n            update_variables(self.model, self.data, self.config, self.dims, dt)\n\n            self._log_newton_iteration_data()\n\n    update_body_q(self.model, self.data, self.config, self.dims, dt)\n    wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n    wp.copy(dest=state_out.body_q, src=self.data.body_q)\n\n    return self.events\n</code></pre>"},{"location":"reference/axion/core/engine/#axion.core.engine.AxionEngine.simulate_scipy","title":"<code>simulate_scipy</code>","text":"<p>Apply the SciPy root-finding algorithm to the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The physics model containing bodies, joints, and other physics properties.</p> required <code>state_in</code> <code>State</code> <p>The input state at the beginning of the time step.</p> required <code>state_out</code> <code>State</code> <p>The output state at the end of the time step. This will be modified by the engine.</p> required <code>dt</code> <code>float</code> <p>The time step duration.</p> required <code>control</code> <code>Control | None</code> <p>Optional control inputs to be applied during the simulation step.</p> <code>None</code> <code>method</code> <code>str</code> <p>The scipy root-finding method to use (default is 'hybr').</p> <code>'hybr'</code> <code>tolerance</code> <code>float</code> <p>The tolerance for convergence (default is 1e-10).</p> <code>1e-10</code> <code>max_iterations</code> <code>int</code> <p>The maximum number of iterations for the solver (default is 5000).</p> <code>5000</code> Source code in <code>src/axion/core/engine.py</code> <pre><code>def simulate_scipy(\n    self,\n    model: Model,\n    state_in: State,\n    state_out: State,\n    dt: float,\n    control: Control | None = None,\n    method: str = \"hybr\",\n    tolerance: float = 1e-10,\n    max_iterations: int = 5000,\n):\n    \"\"\"\n    Apply the SciPy root-finding algorithm to the simulation.\n\n    Args:\n        model: The physics model containing bodies, joints, and other physics properties.\n        state_in: The input state at the beginning of the time step.\n        state_out: The output state at the end of the time step. This will be modified by the engine.\n        dt: The time step duration.\n        control: Optional control inputs to be applied during the simulation step.\n        method: The scipy root-finding method to use (default is 'hybr').\n        tolerance: The tolerance for convergence (default is 1e-10).\n        max_iterations: The maximum number of iterations for the solver (default is 5000).\n    \"\"\"\n    apply_control(model, state_in, state_out, dt, control)\n    self.integrate_bodies(model, state_in, state_out, dt)\n    self.data.update_state_data(model, state_in, state_out)\n\n    def residual_function(x: np.ndarray) -&gt; np.ndarray:\n        wp.copy(dest=self.data.lambda_prev, src=self.data._lambda)\n\n        # x contains both lambda and body_qd\n        n_lambda = self.dims.con_dim\n        lambda_vals = x[:n_lambda]\n        body_qd_vals = x[n_lambda:]\n\n        # Store current state\n        lambda_backup = wp.clone(self.data._lambda)\n        body_qd_backup = wp.clone(self.data.body_qd)\n\n        try:\n            # Set state from input vector\n            self.data._lambda.assign(lambda_vals)\n            self.data.body_qd.assign(body_qd_vals)\n\n            # Compute residuals (right hand side of the linear system)\n            compute_linear_system(self.data, self.config, self.dims, dt)\n\n            # Residual is concatenation of g and h vector\n            return self.data.res.numpy()\n\n        finally:\n            # Restore original state\n            wp.copy(dest=self.data._lambda, src=lambda_backup)\n            wp.copy(dest=self.data.body_qd, src=body_qd_backup)\n\n    # Initial guess from current state\n    x0 = np.concatenate([self.data._lambda.numpy(), self.data.body_qd.numpy().flatten()])\n\n    # Solve\n    result = scipy.optimize.root(\n        residual_function,\n        x0,\n        method=method,\n        options={\"xtol\": tolerance, \"maxfev\": max_iterations},\n    )\n\n    n_lambda = self.dims.con_dim\n    self.data._lambda.assign(wp.from_numpy(result.x[:n_lambda].astype(np.float32)))\n    body_qd_solution = result.x[n_lambda:][np.newaxis, :]\n    self.data.body_qd.assign(wp.from_numpy(body_qd_solution.astype(np.float32)))\n\n    wp.copy(dest=state_out.body_qd, src=self.data.body_qd)\n    wp.copy(dest=state_out.body_q, src=self.data.body_q)\n</code></pre>"},{"location":"reference/axion/optim/matrix_operator/","title":"matrix_operator","text":"<p>This module provides a linear operator that explicitly builds the full dense system matrix, mirroring the behavior of a direct matrix-based solver.</p> <p>The core component is the DenseSystemOperator class, which implements the matrix-vector product by first constructing the system matrix A, where:</p> <pre><code>A = (J M\u207b\u00b9 J\u1d40 + C)\n</code></pre> <ul> <li>J: The constraint Jacobian matrix.</li> <li>M: The block-diagonal mass matrix (inverse is M\u207b\u00b9).</li> <li>C: A diagonal compliance/regularization matrix.</li> </ul> <p>This operator is primarily useful for debugging, validation, or for smaller systems where the memory cost of the dense matrix is acceptable.</p>"},{"location":"reference/axion/optim/matrix_operator/#axion.optim.matrix_operator.MatrixSystemOperator","title":"<code>MatrixSystemOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator that explicitly builds the dense system matrix A = J M\u207b\u00b9 J\u1d40 + C and uses it for matrix-vector products.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>class MatrixSystemOperator(LinearOperator):\n    \"\"\"\n    A linear operator that explicitly builds the dense system matrix A = J M\u207b\u00b9 J\u1d40 + C\n    and uses it for matrix-vector products.\n    \"\"\"\n\n    def __init__(self, engine):\n        super().__init__(\n            shape=(engine.dims.con_dim, engine.dims.con_dim),\n            dtype=wp.float32,\n            device=engine.device,\n            matvec=None,\n        )\n        self.engine = engine\n\n        # Allocate memory for the full dense matrix\n        self._A = wp.zeros(self.shape, dtype=self.dtype, device=self.device)\n\n    def update(self):\n        \"\"\"Re-computes the dense system matrix _A using the latest system state.\"\"\"\n        self._A.zero_()\n        wp.launch(\n            kernel=update_system_matrix_kernel,\n            dim=self.shape,\n            inputs=[\n                self.engine.data.gen_inv_mass,\n                self.engine.data.constraint_body_idx,\n                self.engine.data.J_values,\n                self.engine.data.C_values,\n            ],\n            outputs=[self._A],\n            device=self.device,\n        )\n\n    def matvec(self, x, y, z, alpha, beta):\n        \"\"\"Computes z = beta * y + alpha * (A @ x) via dense matrix-vector product.\"\"\"\n        A = aslinearoperator(self._A)\n        A.matvec(x=x, y=y, z=z, alpha=alpha, beta=beta)\n</code></pre>"},{"location":"reference/axion/optim/matrix_operator/#axion.optim.matrix_operator.MatrixSystemOperator.matvec","title":"<code>matvec</code>","text":"<p>Computes z = beta * y + alpha * (A @ x) via dense matrix-vector product.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>def matvec(self, x, y, z, alpha, beta):\n    \"\"\"Computes z = beta * y + alpha * (A @ x) via dense matrix-vector product.\"\"\"\n    A = aslinearoperator(self._A)\n    A.matvec(x=x, y=y, z=z, alpha=alpha, beta=beta)\n</code></pre>"},{"location":"reference/axion/optim/matrix_operator/#axion.optim.matrix_operator.MatrixSystemOperator.update","title":"<code>update</code>","text":"<p>Re-computes the dense system matrix _A using the latest system state.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>def update(self):\n    \"\"\"Re-computes the dense system matrix _A using the latest system state.\"\"\"\n    self._A.zero_()\n    wp.launch(\n        kernel=update_system_matrix_kernel,\n        dim=self.shape,\n        inputs=[\n            self.engine.data.gen_inv_mass,\n            self.engine.data.constraint_body_idx,\n            self.engine.data.J_values,\n            self.engine.data.C_values,\n        ],\n        outputs=[self._A],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/optim/matrix_operator/#axion.optim.matrix_operator.update_system_matrix_kernel","title":"<code>update_system_matrix_kernel</code>","text":"<p>Builds the full dense system matrix A = J M\u207b\u00b9 J\u1d40 + C.</p> Source code in <code>src/axion/optim/matrix_operator.py</code> <pre><code>@wp.kernel\ndef update_system_matrix_kernel(\n    body_spatial_inertia: wp.array(dtype=SpatialInertia),\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    C_values: wp.array(dtype=wp.float32),\n    A: wp.array(dtype=wp.float32, ndim=2),\n):\n    \"\"\"Builds the full dense system matrix A = J M\u207b\u00b9 J\u1d40 + C.\"\"\"\n    i, j = wp.tid()\n\n    body_a_i = constraint_body_idx[i, 0]\n    body_b_i = constraint_body_idx[i, 1]\n    J_ia = J_values[i, 0]\n    J_ib = J_values[i, 1]\n\n    body_a_j = constraint_body_idx[j, 0]\n    body_b_j = constraint_body_idx[j, 1]\n    J_ja = J_values[j, 0]\n    J_jb = J_values[j, 1]\n\n    if body_a_i == body_b_i or body_a_j == body_b_j:\n        A[i, j] = 0.0\n\n    A_ij = 0.0\n\n    # Term 1: body_a_i vs body_a_j\n    if body_a_i &gt;= 0 and body_a_i == body_a_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_a_i, body_a_j, J_ia, J_ja)\n\n    # Term 2: body_a_i vs body_b_j\n    if body_a_i &gt;= 0 and body_a_i == body_b_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_a_i, body_b_j, J_ia, J_jb)\n\n    # Term 3: body_b_i vs body_a_j\n    if body_b_i &gt;= 0 and body_b_i == body_a_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_b_i, body_a_j, J_ib, J_ja)\n\n    # Term 4: body_b_i vs body_b_j\n    if body_b_i &gt;= 0 and body_b_i == body_b_j:\n        A_ij += _compute_Aij(body_spatial_inertia, body_b_i, body_b_j, J_ib, J_jb)\n\n    # Add compliance term C_ij (only on diagonal)\n    if i == j:\n        A_ij += C_values[i]\n\n    A[i, j] = A_ij\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/","title":"matrixfree_operator","text":"<p>This module provides a matrix-free linear operator for solving the mixed-integer system of equations that arises in velocity-based physics simulation.</p> <p>The core component is the SystemOperator class, which implements the matrix-vector product for the system matrix A, where:</p> <pre><code>A = (J M\u207b\u00b9 J\u1d40 + C)\n</code></pre> <ul> <li>J: The constraint Jacobian matrix.</li> <li>M: The block-diagonal mass matrix (inverse is M\u207b\u00b9).</li> <li>C: A diagonal compliance/regularization matrix.</li> </ul> <p>This operator is designed to be used with iterative linear solvers like Conjugate Residual (CR) or Conjugate Gradient (CG), allowing the system to be solved without ever forming the potentially very large and dense matrix A explicitly.</p>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.MatrixFreeSystemOperator","title":"<code>MatrixFreeSystemOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A matrix-free linear operator for the system A = J M\u207b\u00b9 J\u1d40 + C.</p> <p>This class provides a .matvec() method that computes the matrix-vector product A @ x without explicitly constructing the matrix A. It is intended to be used with iterative linear solvers like <code>cr_solver</code>.</p> Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>class MatrixFreeSystemOperator(LinearOperator):\n    \"\"\"\n    A matrix-free linear operator for the system A = J M\u207b\u00b9 J\u1d40 + C.\n\n    This class provides a .matvec() method that computes the matrix-vector\n    product A @ x without explicitly constructing the matrix A. It is intended\n    to be used with iterative linear solvers like `cr_solver`.\n    \"\"\"\n\n    def __init__(self, engine):\n        \"\"\"\n        Initializes the operator with data from the main physics engine.\n\n        Args:\n            engine: An instance of the main physics engine (e.g., NSNEngine)\n                    that holds all the necessary system data (Jacobians,\n                    masses, constraint info, etc.).\n        \"\"\"\n        super().__init__(\n            shape=(engine.dims.con_dim, engine.dims.con_dim),\n            dtype=wp.float32,\n            device=engine.device,\n            matvec=None,\n        ),\n        self.engine = engine\n\n        # Pre-allocate temporary buffers for intermediate calculations.\n        self._tmp_dyn_vec = wp.zeros(engine.dims.N_b, dtype=wp.spatial_vector, device=engine.device)\n        self._tmp_con_vec = wp.zeros(engine.dims.con_dim, dtype=wp.float32, device=engine.device)\n\n    def matvec(self, x, y, z, alpha, beta):\n        \"\"\"\n        Computes the matrix-vector product: z = beta * y + alpha * (A @ x).\n        \"\"\"\n        # --- Step 1: Compute v\u2081 = J\u1d40 @ x ---\n        self._tmp_dyn_vec.zero_()\n        wp.launch(\n            kernel=kernel_J_transpose_matvec,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self.engine.data.constraint_body_idx,\n                self.engine.data.J_values,\n                x,\n            ],\n            outputs=[self._tmp_dyn_vec],\n            device=self.device,\n        )\n\n        # --- Step 2: Compute v\u2082 = M\u207b\u00b9 @ v\u2081 ---\n        wp.launch(\n            kernel=kernel_inv_mass_matvec,\n            dim=self.engine.dims.N_b,\n            inputs=[\n                self.engine.data.gen_inv_mass,\n                self._tmp_dyn_vec,\n            ],\n            outputs=[self._tmp_dyn_vec],\n            device=self.device,\n        )\n\n        # --- Step 3: Compute v\u2083 = J @ v\u2082 ---\n        wp.launch(\n            kernel=kernel_J_matvec,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self.engine.data.constraint_body_idx,\n                self.engine.data.J_values,\n                self._tmp_dyn_vec,\n            ],\n            outputs=[self._tmp_con_vec],\n            device=self.device,\n        )\n\n        # --- Step 4: Compute z = beta * y + alpha * (v\u2083 + C @ x) ---\n        wp.launch(\n            kernel=kernel_finalize_matvec,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self._tmp_con_vec,  # This is J M\u207b\u00b9 J\u1d40 @ x\n                self.engine.data.C_values,\n                x,  # original x vector\n                y,  # original y vector\n                alpha,  # alpha scalar\n                beta,  # beta scalar\n                z,  # The final output vector\n            ],\n            device=self.device,\n        )\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.MatrixFreeSystemOperator.__init__","title":"<code>__init__</code>","text":"<p>Initializes the operator with data from the main physics engine.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <p>An instance of the main physics engine (e.g., NSNEngine)     that holds all the necessary system data (Jacobians,     masses, constraint info, etc.).</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>def __init__(self, engine):\n    \"\"\"\n    Initializes the operator with data from the main physics engine.\n\n    Args:\n        engine: An instance of the main physics engine (e.g., NSNEngine)\n                that holds all the necessary system data (Jacobians,\n                masses, constraint info, etc.).\n    \"\"\"\n    super().__init__(\n        shape=(engine.dims.con_dim, engine.dims.con_dim),\n        dtype=wp.float32,\n        device=engine.device,\n        matvec=None,\n    ),\n    self.engine = engine\n\n    # Pre-allocate temporary buffers for intermediate calculations.\n    self._tmp_dyn_vec = wp.zeros(engine.dims.N_b, dtype=wp.spatial_vector, device=engine.device)\n    self._tmp_con_vec = wp.zeros(engine.dims.con_dim, dtype=wp.float32, device=engine.device)\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.MatrixFreeSystemOperator.matvec","title":"<code>matvec</code>","text":"<p>Computes the matrix-vector product: z = beta * y + alpha * (A @ x).</p> Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>def matvec(self, x, y, z, alpha, beta):\n    \"\"\"\n    Computes the matrix-vector product: z = beta * y + alpha * (A @ x).\n    \"\"\"\n    # --- Step 1: Compute v\u2081 = J\u1d40 @ x ---\n    self._tmp_dyn_vec.zero_()\n    wp.launch(\n        kernel=kernel_J_transpose_matvec,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self.engine.data.constraint_body_idx,\n            self.engine.data.J_values,\n            x,\n        ],\n        outputs=[self._tmp_dyn_vec],\n        device=self.device,\n    )\n\n    # --- Step 2: Compute v\u2082 = M\u207b\u00b9 @ v\u2081 ---\n    wp.launch(\n        kernel=kernel_inv_mass_matvec,\n        dim=self.engine.dims.N_b,\n        inputs=[\n            self.engine.data.gen_inv_mass,\n            self._tmp_dyn_vec,\n        ],\n        outputs=[self._tmp_dyn_vec],\n        device=self.device,\n    )\n\n    # --- Step 3: Compute v\u2083 = J @ v\u2082 ---\n    wp.launch(\n        kernel=kernel_J_matvec,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self.engine.data.constraint_body_idx,\n            self.engine.data.J_values,\n            self._tmp_dyn_vec,\n        ],\n        outputs=[self._tmp_con_vec],\n        device=self.device,\n    )\n\n    # --- Step 4: Compute z = beta * y + alpha * (v\u2083 + C @ x) ---\n    wp.launch(\n        kernel=kernel_finalize_matvec,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self._tmp_con_vec,  # This is J M\u207b\u00b9 J\u1d40 @ x\n            self.engine.data.C_values,\n            x,  # original x vector\n            y,  # original y vector\n            alpha,  # alpha scalar\n            beta,  # beta scalar\n            z,  # The final output vector\n        ],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.kernel_J_matvec","title":"<code>kernel_J_matvec</code>","text":"<p>Computes the matrix-vector product: out_vec = J @ in_vec.</p> <p>This kernel iterates over each constraint and gathers values from the dynamics-space vector (in_vec) to produce the constraint-space vector (out_vec).</p> <p>Parameters:</p> Name Type Description Default <code>in_vec</code> <code>array(dtype=spatial_vector)</code> <p>A vector in dynamics space (e.g., M\u207b\u00b9 @ J\u1d40 @ x).</p> required <code>out_vec</code> <code>array(dtype=float32)</code> <p>The resulting vector in constraint space.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_J_matvec(\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    in_vec: wp.array(dtype=wp.spatial_vector),\n    # Output array\n    out_vec: wp.array(dtype=wp.float32),\n):\n    \"\"\"\n    Computes the matrix-vector product: out_vec = J @ in_vec.\n\n    This kernel iterates over each constraint and gathers values from the\n    dynamics-space vector (in_vec) to produce the constraint-space vector (out_vec).\n\n    Args:\n        in_vec: A vector in dynamics space (e.g., M\u207b\u00b9 @ J\u1d40 @ x).\n        out_vec: The resulting vector in constraint space.\n    \"\"\"\n    constraint_idx = wp.tid()\n\n    body_a = constraint_body_idx[constraint_idx, 0]\n    body_b = constraint_body_idx[constraint_idx, 1]\n\n    J_ia = J_values[constraint_idx, 0]\n    J_ib = J_values[constraint_idx, 1]\n\n    result = 0.0\n    if body_a &gt;= 0:\n        result += wp.dot(J_ia, in_vec[body_a])\n    if body_b &gt;= 0:\n        result += wp.dot(J_ib, in_vec[body_b])\n\n    out_vec[constraint_idx] = result\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.kernel_J_transpose_matvec","title":"<code>kernel_J_transpose_matvec</code>","text":"<p>Computes the matrix-vector product: out_vec = J\u1d40 @ vec_x.</p> <p>This kernel iterates over each constraint (the dimension of vec_x) and scatters the results into the dynamics-space vector (out_vec) using atomic adds.</p> <p>Parameters:</p> Name Type Description Default <code>vec_x</code> <code>array(dtype=float32)</code> <p>A vector in constraint space (e.g., delta_lambda).</p> required <code>out_vec</code> <code>array(dtype=spatial_vector)</code> <p>A vector in dynamics space (size num_bodies * 6) to store the result.      This vector MUST be zero-initialized before calling this kernel.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_J_transpose_matvec(\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    vec_x: wp.array(dtype=wp.float32),\n    # Output array\n    out_vec: wp.array(dtype=wp.spatial_vector),\n):\n    \"\"\"\n    Computes the matrix-vector product: out_vec = J\u1d40 @ vec_x.\n\n    This kernel iterates over each constraint (the dimension of vec_x) and\n    scatters the results into the dynamics-space vector (out_vec) using atomic adds.\n\n    Args:\n        vec_x: A vector in constraint space (e.g., delta_lambda).\n        out_vec: A vector in dynamics space (size num_bodies * 6) to store the result.\n                 This vector MUST be zero-initialized before calling this kernel.\n    \"\"\"\n    constraint_idx = wp.tid()\n\n    body_a = constraint_body_idx[constraint_idx, 0]\n    body_b = constraint_body_idx[constraint_idx, 1]\n\n    J_ia = J_values[constraint_idx, 0]\n    J_ib = J_values[constraint_idx, 1]\n    x_i = vec_x[constraint_idx]\n\n    if body_a &gt;= 0:\n        out_vec[body_a] += x_i * J_ia\n    if body_b &gt;= 0:\n        out_vec[body_b] += x_i * J_ib\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.kernel_finalize_matvec","title":"<code>kernel_finalize_matvec</code>","text":"<p>Performs the final step of the matvec computation: z = beta * y + alpha * ( (J M\u207b\u00b9 J\u1d40 @ x) + (C @ x) )</p> <p>Parameters:</p> Name Type Description Default <code>J_M_inv_Jt_x</code> <code>array(dtype=float32)</code> <p>The result of J @ M\u207b\u00b9 @ J\u1d40 @ x.</p> required <code>C_values</code> <code>array(dtype=float32)</code> <p>The diagonal entries of the compliance matrix C.</p> required <code>vec_x</code> <code>array(dtype=float32)</code> <p>The original input vector 'x' to the matvec operation.</p> required <code>vec_y</code> <code>array(dtype=float32)</code> <p>The input vector 'y'.</p> required <code>alpha</code> <code>float</code> <p>Scalar multiplier for the A@x term.</p> required <code>beta</code> <code>float</code> <p>Scalar multiplier for the y term.</p> required <code>out_vec_z</code> <code>array(dtype=float32)</code> <p>The final output vector z.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_finalize_matvec(\n    J_M_inv_Jt_x: wp.array(dtype=wp.float32),\n    C_values: wp.array(dtype=wp.float32),\n    vec_x: wp.array(dtype=wp.float32),\n    vec_y: wp.array(dtype=wp.float32),\n    alpha: float,\n    beta: float,\n    out_vec_z: wp.array(dtype=wp.float32),\n):\n    \"\"\"\n    Performs the final step of the matvec computation:\n    z = beta * y + alpha * ( (J M\u207b\u00b9 J\u1d40 @ x) + (C @ x) )\n\n    Args:\n        J_M_inv_Jt_x: The result of J @ M\u207b\u00b9 @ J\u1d40 @ x.\n        C_values: The diagonal entries of the compliance matrix C.\n        vec_x: The original input vector 'x' to the matvec operation.\n        vec_y: The input vector 'y'.\n        alpha: Scalar multiplier for the A@x term.\n        beta: Scalar multiplier for the y term.\n        out_vec_z: The final output vector z.\n    \"\"\"\n    i = wp.tid()\n    c_times_x = C_values[i] * vec_x[i]\n    a_times_x = J_M_inv_Jt_x[i] + c_times_x\n\n    # The crucial change is here: including beta * y\n    if beta == 0.0:\n        out_vec_z[i] = alpha * a_times_x\n    else:\n        out_vec_z[i] = beta * vec_y[i] + alpha * a_times_x\n</code></pre>"},{"location":"reference/axion/optim/matrixfree_operator/#axion.optim.matrixfree_operator.kernel_inv_mass_matvec","title":"<code>kernel_inv_mass_matvec</code>","text":"<p>Computes the matrix-vector product: out_vec = M\u207b\u00b9 @ in_vec.</p> <p>M\u207b\u00b9 is the block-diagonal inverse mass matrix, composed of a 3x3 inverse inertia tensor and a scalar inverse mass for each body.</p> <p>Parameters:</p> Name Type Description Default <code>in_vec</code> <code>array(dtype=spatial_vector)</code> <p>A vector in dynamics space (e.g., the result of J\u1d40 @ x).</p> required <code>out_vec</code> <code>array(dtype=spatial_vector)</code> <p>The resulting vector in dynamics space.</p> required Source code in <code>src/axion/optim/matrixfree_operator.py</code> <pre><code>@wp.kernel\ndef kernel_inv_mass_matvec(\n    gen_inv_mass: wp.array(dtype=SpatialInertia),\n    in_vec: wp.array(dtype=wp.spatial_vector),\n    out_vec: wp.array(dtype=wp.spatial_vector),\n):\n    \"\"\"\n    Computes the matrix-vector product: out_vec = M\u207b\u00b9 @ in_vec.\n\n    M\u207b\u00b9 is the block-diagonal inverse mass matrix, composed of a 3x3 inverse\n    inertia tensor and a scalar inverse mass for each body.\n\n    Args:\n        in_vec: A vector in dynamics space (e.g., the result of J\u1d40 @ x).\n        out_vec: The resulting vector in dynamics space.\n    \"\"\"\n    body_idx = wp.tid()\n\n    out_vec[body_idx] = to_spatial_momentum(gen_inv_mass[body_idx], in_vec[body_idx])\n</code></pre>"},{"location":"reference/axion/optim/preconditioner/","title":"preconditioner","text":"<p>Jacobi preconditioner for the system matrix A = J M\u207b\u00b9 J\u1d40 + C.</p>"},{"location":"reference/axion/optim/preconditioner/#axion.optim.preconditioner.JacobiPreconditioner","title":"<code>JacobiPreconditioner</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A Jacobi (diagonal) preconditioner for the system matrix A = J M\u207b\u00b9 J\u1d40 + C.</p> <p>This class provides a .matvec() method that applies the inverse of the diagonal of A, for use with Warp's iterative solvers.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>class JacobiPreconditioner(LinearOperator):\n    \"\"\"\n    A Jacobi (diagonal) preconditioner for the system matrix A = J M\u207b\u00b9 J\u1d40 + C.\n\n    This class provides a .matvec() method that applies the inverse of the\n    diagonal of A, for use with Warp's iterative solvers.\n    \"\"\"\n\n    def __init__(self, engine):\n        super().__init__(\n            shape=(engine.dims.con_dim, engine.dims.con_dim),\n            dtype=wp.float32,\n            device=engine.device,\n            matvec=None,  # Will be set later\n        )\n        self.engine = engine\n\n        # Storage for the inverse diagonal elements\n        self._P_inv_diag = wp.zeros(engine.dims.con_dim, dtype=wp.float32, device=self.device)\n\n    def update(self):\n        \"\"\"\n        Re-computes the preconditioner's data. This must be called each time\n        the Jacobian (J) or compliance (C) values change.\n        \"\"\"\n        wp.launch(\n            kernel=compute_inv_diag_kernel,\n            dim=self.engine.dims.con_dim,\n            inputs=[\n                self.engine.data.constraint_body_idx,\n                self.engine.data.gen_inv_mass,\n                self.engine.data.J_values,\n                self.engine.data.C_values,\n            ],\n            outputs=[self._P_inv_diag],\n            device=self.device,\n        )\n\n    def matvec(self, x, y, z, alpha, beta):\n        \"\"\"\n        Performs the preconditioning operation z = beta*y + alpha*(M\u207b\u00b9@x),\n        where M\u207b\u00b9 is the inverse diagonal matrix stored in `_P_inv_diag`.\n        \"\"\"\n        wp.launch(\n            kernel=apply_preconditioner_kernel,\n            dim=self.engine.dims.con_dim,\n            inputs=[self._P_inv_diag, x, y, alpha, beta, z],\n            device=self.device,\n        )\n</code></pre>"},{"location":"reference/axion/optim/preconditioner/#axion.optim.preconditioner.JacobiPreconditioner.matvec","title":"<code>matvec</code>","text":"<p>Performs the preconditioning operation z = betay + alpha(M\u207b\u00b9@x), where M\u207b\u00b9 is the inverse diagonal matrix stored in <code>_P_inv_diag</code>.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>def matvec(self, x, y, z, alpha, beta):\n    \"\"\"\n    Performs the preconditioning operation z = beta*y + alpha*(M\u207b\u00b9@x),\n    where M\u207b\u00b9 is the inverse diagonal matrix stored in `_P_inv_diag`.\n    \"\"\"\n    wp.launch(\n        kernel=apply_preconditioner_kernel,\n        dim=self.engine.dims.con_dim,\n        inputs=[self._P_inv_diag, x, y, alpha, beta, z],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/optim/preconditioner/#axion.optim.preconditioner.JacobiPreconditioner.update","title":"<code>update</code>","text":"<p>Re-computes the preconditioner's data. This must be called each time the Jacobian (J) or compliance (C) values change.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>def update(self):\n    \"\"\"\n    Re-computes the preconditioner's data. This must be called each time\n    the Jacobian (J) or compliance (C) values change.\n    \"\"\"\n    wp.launch(\n        kernel=compute_inv_diag_kernel,\n        dim=self.engine.dims.con_dim,\n        inputs=[\n            self.engine.data.constraint_body_idx,\n            self.engine.data.gen_inv_mass,\n            self.engine.data.J_values,\n            self.engine.data.C_values,\n        ],\n        outputs=[self._P_inv_diag],\n        device=self.device,\n    )\n</code></pre>"},{"location":"reference/axion/optim/preconditioner/#axion.optim.preconditioner.apply_preconditioner_kernel","title":"<code>apply_preconditioner_kernel</code>","text":"<p>Applies the Jacobi preconditioner: z = beta*y + alpha * P\u207b\u00b9 * x</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>@wp.kernel\ndef apply_preconditioner_kernel(\n    P_inv_diag: wp.array(dtype=wp.float32),\n    vec_x: wp.array(dtype=wp.float32),\n    vec_y: wp.array(dtype=wp.float32),\n    alpha: float,\n    beta: float,\n    out_vec_z: wp.array(dtype=wp.float32),\n):\n    \"\"\"Applies the Jacobi preconditioner: z = beta*y + alpha * P\u207b\u00b9 * x\"\"\"\n    i = wp.tid()\n    preconditioned_x = P_inv_diag[i] * vec_x[i]\n\n    if beta == 0.0:\n        out_vec_z[i] = alpha * preconditioned_x\n    else:\n        out_vec_z[i] = beta * vec_y[i] + alpha * preconditioned_x\n</code></pre>"},{"location":"reference/axion/optim/preconditioner/#axion.optim.preconditioner.compute_inv_diag_kernel","title":"<code>compute_inv_diag_kernel</code>","text":"<p>Computes the inverse of the diagonal of the system matrix A = J M\u207b\u00b9 J\u1d40 + C. The result P_inv_diag[i] = 1.0 / A[i,i] is stored.</p> Source code in <code>src/axion/optim/preconditioner.py</code> <pre><code>@wp.kernel\ndef compute_inv_diag_kernel(\n    constraint_body_idx: wp.array(dtype=wp.int32, ndim=2),\n    gen_inv_mass: wp.array(dtype=SpatialInertia),\n    J_values: wp.array(dtype=wp.spatial_vector, ndim=2),\n    C_values: wp.array(dtype=wp.float32),\n    # Output array\n    P_inv_diag: wp.array(dtype=wp.float32),\n):\n    \"\"\"\n    Computes the inverse of the diagonal of the system matrix A = J M\u207b\u00b9 J\u1d40 + C.\n    The result P_inv_diag[i] = 1.0 / A[i,i] is stored.\n    \"\"\"\n    constraint_idx = wp.tid()\n\n    body_a = constraint_body_idx[constraint_idx, 0]\n    body_b = constraint_body_idx[constraint_idx, 1]\n\n    result = 0.0\n    if body_a &gt;= 0:\n        Minv_a = gen_inv_mass[body_a]\n        J_ia = J_values[constraint_idx, 0]\n        result += wp.dot(J_ia, to_spatial_momentum(Minv_a, J_ia))\n    if body_b &gt;= 0:\n        Minv_b = gen_inv_mass[body_b]\n        J_ib = J_values[constraint_idx, 1]\n        result += wp.dot(J_ib, to_spatial_momentum(Minv_b, J_ib))\n\n    # Add diagonal compliance term C[i,i]\n    diag_A = result + C_values[constraint_idx]\n\n    # Compute and store inverse, with stabilization\n    P_inv_diag[constraint_idx] = 1.0 / (diag_A + 1e-6)\n</code></pre>"},{"location":"theory/constraints/","title":"Constraints Formulation","text":"<p>This section establishes the mathematical foundation for representing articulated bodies and their interactions as constraint equations. Understanding these constraint formulations is essential before exploring how they are enforced through optimization principles and numerical methods.</p> <p>In Axion, all physical interactions\u2014joints, contacts, and friction\u2014are unified under a single mathematical framework of constraint equations. This creates a large-scale system that captures the essential physics while enabling robust numerical solution.</p>"},{"location":"theory/constraints/#1-constraint-formulations-position-and-velocity","title":"1. Constraint Formulations: Position and Velocity","text":"<p>In computational mechanics, constraint equations can be enforced at the level of position or velocity. The choice of which level to use has profound implications for the simulator's stability and accuracy.</p>"},{"location":"theory/constraints/#position-level-formulation-integral-form","title":"Position-Level Formulation (Integral Form)","text":"<p>This formulation defines constraints using the geometric configuration of the bodies, \\(q\\). It is the most direct and robust method as it targets the \"ground truth\" of the physical system.</p> <ul> <li>Unilateral (Inequality) Constraints: For non-penetration, the gap distance function c(q) must be non-negative:</li> </ul> \\[ \\mathbf{c}(\\mathbf{q}) \\geq \\mathbf{0} \\] <ul> <li>Bilateral (Equality) Constraints: For a joint, a constraint function c(q) must be exactly zero:</li> </ul> \\[ \\mathbf{c}(\\mathbf{q}) = \\mathbf{0} \\] <p>Solving constraints at this level guarantees zero positional error, but it requires more advanced non-linear solvers.</p>"},{"location":"theory/constraints/#velocity-level-formulation-differential-form","title":"Velocity-Level Formulation (Differential Form)","text":"<p>This common alternative is derived by taking the time derivative of the position-level constraints. Using the chain rule and the kinematic mapping \\(\\dot{\\mathbf{q}} = \\mathbf{G}(\\mathbf{q}) \\cdot \\mathbf{u}\\), we get</p> \\[ \\dot{\\mathbf{c}} = \\frac{\\partial \\mathbf{c}}{\\partial \\mathbf{q}} \\cdot \\frac{d\\mathbf{q}}{dt} = \\frac{\\partial \\mathbf{c}}{\\partial \\mathbf{q}} \\cdot \\mathbf{G}(\\mathbf{q}) \\cdot \\mathbf{u} = \\mathbf{J} \\cdot \\mathbf{u}, \\] <p>where \\(\\mathbf{J} = \\frac{\\partial \\mathbf{c}}{\\partial \\mathbf{q}} \\cdot \\mathbf{G}(\\mathbf{q})\\) is the velocity Jacobian that maps generalized velocities \\(\\mathbf{u}\\) to constraint derivatives.</p> <p>Mathematical Notation</p> <p>For detailed definitions of \\(\\mathbf{J}\\), \\(\\mathbf{G}\\), and other symbols, see the Notation page.</p> <ul> <li>Bilateral Constraint: The velocity constraint becomes</li> </ul> \\[ \\mathbf{J} \\cdot \\mathbf{u} = \\mathbf{0}, \\] <p>enforcing that the relative velocity in the constrained directions is zero.</p> <ul> <li>Unilateral Constraint: The non-penetration condition becomes a complementarity problem on velocities: when a contact is active (\\(c(q) = 0\\)), the relative normal velocity must be non-negative</li> </ul> \\[ \\dot{c} = \\mathbf{J} \\cdot \\mathbf{u} \\ge 0. \\] <p>This forms the basis of many Linear Complementarity Problem (LCP) solvers.</p>"},{"location":"theory/constraints/#the-problem-of-drift-and-stabilization","title":"The Problem of \"Drift\" and Stabilization","text":"<p>While computationally simpler, velocity-level solvers suffer from a critical flaw: numerical drift. Enforcing \\(\\mathbf{J}\\mathbf{u} = \\mathbf{0}\\) only ensures the velocity is correct at a given instant. Due to numerical integration errors accumulating over many time steps, the underlying position constraint \\(\\mathbf{c}(q)\\) will inevitably \"drift\" away from zero. This manifests as joints slowly pulling apart or objects gradually sinking into one another.</p> <p>To combat this, velocity-based solvers must add a feedback rule to push the system back toward a valid state. The most common method is Baumgarte Stabilization, which re-frames the constraint force as a physical spring-damper.</p> <p>Conceptually, the constraint force \u03bb is modeled as an implicit Hookean spring that acts to close any existing positional error c(q):</p> \\[ \\boldsymbol{\\lambda} = -k \\cdot \\mathbf{c}(\\mathbf{q}) - b \\cdot \\mathbf{v}_{rel} \\] <p>Here, \\(\\mathbf{c}(\\mathbf{q})\\) is the position error (e.g., penetration depth), \\(\\mathbf{v}_{\\text{rel}}\\) is the relative velocity, \\(k\\) is a spring stiffness, and \\(b\\) is a damping coefficient. This force pulls the bodies back into alignment.</p> <p>To be used in a velocity-level solver, this is rearranged into a modified velocity constraint. The result is a velocity goal that not only enforces the constraint but also tries to correct a fraction of the position error over the next time step \\(h\\). This introduces two user-facing parameters:</p> <ol> <li> <p>Error Reduction Parameter (ERP): A factor, typically between 0 and 1, that specifies what fraction of the positional error to correct in the next time step. It is often calculated as \\(\\text{ERP} = \\frac{h k}{h k + b}\\). An ERP of 0.2 means the system will attempt to resolve 20% of the penetration depth in the current step.</p> </li> <li> <p>Constraint Force Mixing (CFM): A small, soft parameter, proportional to \\(\\frac{1}{h k + b}\\), that is added to the diagonal of the constraint matrix. It makes the constraint \"softer,\" allowing for a small amount of violation in exchange for a much more stable and well-conditioned numerical system. This is especially useful when dealing with redundant contacts.</p> </li> </ol> <p>While this spring-based stabilization is more physically intuitive, tuning ERP and CFM values is notoriously difficult. Poor tuning can lead to spongy, oscillating joints or bouncy contacts.</p> <p>Axion's direct, position-level DVI formulation elegantly sidesteps this entire problem. By solving for the position constraints directly, it eliminates drift by design, removing the need for fragile stabilization hacks and ensuring superior long-term stability.</p>"},{"location":"theory/constraints/#2-contact-constraints","title":"2. Contact Constraints","text":"<p>Contact constraints prevent bodies from interpenetrating, representing one of the most challenging aspects of physics simulation due to their unilateral (inequality) nature.</p>"},{"location":"theory/constraints/#position-level-formulation","title":"Position-Level Formulation","text":"<p>For each potential contact point, we define a gap function \\(\\mathbf{c}_{\\text{contact}}(\\mathbf{q})\\) that measures the signed distance between bodies:</p> \\[ c_{\\text{contact}}(\\mathbf{q}) \\geq 0 \\] <p>When \\(c_{\\text{contact}} &gt; 0\\), bodies are separated; when \\(c_{\\text{contact}} = 0\\), bodies are just touching.</p> <p>The contact constraint is formulated as a Nonlinear Complementarity Problem (NCP):</p> \\[ 0 \\leq \\lambda_n \\perp \\mathbf{c}_{\\text{contact}}(\\mathbf{q}) \\geq 0 \\] <p>This mathematical relationship captures the essential physics:</p> <ul> <li>Non-negativity: Contact impulses are repulsive (\\(\\lambda_n \\geq 0\\)) and no penetration occurs (\\(\\mathbf{c}(\\mathbf{q}) \\geq 0\\))  </li> <li>Complementarity: Either bodies are separated (\\(\\mathbf{c}(\\mathbf{q}) &gt; 0\\), \\(\\lambda_n = 0\\)) or in contact (\\(\\mathbf{c}(\\mathbf{q}) = 0\\), \\(\\lambda_n \\geq 0\\))</li> </ul> <p>By solving this position-level problem directly, Axion finds the exact impulses required to satisfy the non-penetration constraint, resulting in stable simulation without drift.</p>"},{"location":"theory/constraints/#velocity-level-formulation-alternative","title":"Velocity-Level Formulation (Alternative)","text":"<p>For contrast, contacts can also be formulated at the velocity level. Taking the time derivative of the position constraint, we get a condition on the relative normal velocity \\(\\mathbf{v}_n = \\mathbf{J}_n \\cdot \\mathbf{u}\\):</p> \\[ 0 \\leq \\lambda_n \\perp \\mathbf{v}_n \\geq 0 \\] <p>This forms a Linear Complementarity Problem (LCP) that ensures bodies don't move further into each other when in contact. However, this approach requires additional stabilization mechanisms to prevent drift, as discussed in Section 1.</p>"},{"location":"theory/constraints/#3-friction-constraints","title":"3. Friction Constraints","text":"<p>Friction constraints apply tangential impulses that resist sliding motion between contacting bodies. Axion uses the smooth, isotropic Coulomb friction model derived from the principle of maximal dissipation.</p>"},{"location":"theory/constraints/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>The principle of maximal dissipation states that the friction impulse \u03bb<sub>t</sub> will remove the maximum amount of kinetic energy from the system, subject to the Coulomb constraint that its magnitude is limited by the normal impulse \u03bb<sub>n</sub> and the coefficient of friction \u03bc:</p> \\[ \\|\\boldsymbol{\\lambda}_t\\| \\leq \\mu \\cdot \\lambda_n \\] <p>The Karush-Kuhn-Tucker (KKT) conditions for this model precisely describe the friction behavior:</p> <ol> <li>Sliding: If there is relative tangential velocity (\\(\\mathbf{v}_t \\neq \\mathbf{0}\\)), the friction impulse opposes it at maximum magnitude: \\(\\boldsymbol{\\lambda}_t = -\\mu\\lambda_n \\mathbf{v}_t/\\|\\mathbf{v}_t\\|\\)</li> <li>Sticking: If there is no relative tangential velocity (\\(\\mathbf{v}_t = \\mathbf{0}\\)), the friction impulse is whatever is necessary to prevent motion, up to the maximum limit: \\(\\|\\boldsymbol{\\lambda}_t\\| \\leq \\mu\\lambda_n\\)</li> </ol> <p>This principle-based formulation is implemented using an NCP-function and a fixed-point iteration, which recasts the friction model into a symmetric system that fits seamlessly into the non-smooth Newton solver covered in Nonlinear System.</p>"},{"location":"theory/constraints/#4-joint-constraints","title":"4. Joint Constraints","text":"<p>Joints connect bodies and restrict their relative motion. In Axion, joints are implemented using the same unified constraint framework as contacts and friction. The engine employs a constraints-based (or full-coordinate) approach, where each rigid body retains its full 6 degrees of freedom (DOFs), and the solver computes the exact joint impulses required to enforce the desired motion restriction.</p> <p>Currently, the primary joint type implemented in Axion is the Revolute Joint.</p>"},{"location":"theory/constraints/#mathematical-model","title":"Mathematical Model","text":"<p>Like contacts, joint constraints can be defined at either the position or velocity level. A revolute joint (or hinge) is modeled as a set of five simultaneous bilateral (equality) constraints. Axion solves these directly at the position level to ensure maximum stability.</p> <p>The constraint functions \\(\\mathbf{c}(q)\\) are defined to be zero when the joint is perfectly aligned:</p> <ol> <li>Anchor Points Coincide (3 DOFs): The world-space positions of the anchor points on each body must be equal.</li> </ol> \\[ \\mathbf{c_\\text{trans}}(q) = \\mathbf{p_\\text{child}} - \\mathbf{p_\\text{parent}} = \\mathbf{0} \\] <ol> <li>Hinge Axes Collinear (2 DOFs): The designated axes on each body must remain aligned.</li> </ol> <p>The solver finds the joint impulses \\(\\boldsymbol{\\lambda}_j\\) required to enforce \\(\\mathbf{c}(q) = \\mathbf{0}\\). Because Axion solves the position-level equation directly via its non-smooth Newton method, any numerical error that would cause the joint to separate is corrected automatically.</p> <p>Alternative: Velocity-Level Formulation</p> <p>In contrast, many simulators formulate joints at the velocity level by taking the time derivative of the position constraint:</p> \\[ \\dot{\\mathbf{c}}(\\mathbf{q}) = \\mathbf{J} \\cdot \\mathbf{u} = \\mathbf{0} \\] <p>Here, the solver finds impulses that force the relative velocity u along the constrained degrees of freedom to be zero. As discussed in Section 1, this approach suffers from numerical drift, where integration errors cause the positional error c(q) to grow over time, making the joint appear to pull apart. This necessitates corrective measures like Baumgarte stabilization, which can be difficult to tune.</p>"},{"location":"theory/constraints/#conclusion-from-constraints-to-optimization","title":"Conclusion: From Constraints to Optimization","text":"<p>The constraint formulations presented in this section\u2014position/velocity-level approaches, contact complementarity, friction stick-slip behavior, and joint restrictions\u2014create a complex system mixing equalities and inequalities that must be satisfied simultaneously.</p> <p>The key question becomes: How do we determine the constraint impulses \u03bb that enforce all these constraints while respecting the system dynamics?</p> <p>This challenge is addressed through Gauss's Principle of Least Constraint, which provides a principled optimization framework for determining these impulses. The principle transforms the constraint enforcement problem into an optimization problem that can be solved numerically.</p> <p>\u2192 Next: Gauss's Principle of Least Constraint</p>"},{"location":"theory/core-concepts/","title":"Core Concepts","text":"<p>This section provides a high-level mathematical overview of how Axion formulates and solves the physics simulation problem. Understanding these concepts is essential for grasping the theoretical foundation underlying the simulator's robust and unified approach.</p>"},{"location":"theory/core-concepts/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>Axion's physics engine is built on a unified mathematical framework that treats all physical phenomena\u2014articulated body dynamics, contact interactions, and joint constraints\u2014as a single, coupled system of equations. This approach provides superior stability and accuracy compared to traditional methods that handle these phenomena separately.</p>"},{"location":"theory/core-concepts/#articulated-bodies","title":"Articulated Bodies","text":"<p>Axion represents articulated body systems using generalized coordinates and velocities that describe the system's configuration and motion. The dynamics are governed by:</p> \\[ \\mathbf{\\tilde{M}}(\\mathbf{q}) \\Delta\\mathbf{u} = \\mathbf{f}_{\\text{ext}} h + \\mathbf{J}^T(\\mathbf{q}) \\boldsymbol{\\lambda} \\] <p>This captures how velocity changes result from external forces and constraint impulses. The meaning and derivation of these constraint impulses will be explained in Gauss's Principle of Least Constraint.</p> <p>Mathematical Notation</p> <p>For detailed definitions of all symbols (\\(\\mathbf{q}\\), \\(\\mathbf{u}\\), \\(\\mathbf{\\tilde{M}}\\), \\(\\mathbf{J}\\), \\(\\boldsymbol{\\lambda}\\), etc.), see the Notation page.</p>"},{"location":"theory/core-concepts/#contact-and-constraint-formulation","title":"Contact and Constraint Formulation","text":"<p>Physical interactions are mathematically encoded as constraints:</p> <ul> <li>Joint Constraints (bilateral): Enforce exact geometric relationships between bodies</li> <li>Contact Constraints (unilateral): Prevent body interpenetration  </li> <li>Friction Constraints: Model stick-slip behavior through complementarity conditions</li> </ul> <p>These constraints create a system mixing equalities and inequalities, requiring specialized mathematical treatment to solve simultaneously.</p>"},{"location":"theory/core-concepts/#solution-approach","title":"Solution Approach","text":"<p>Axion's approach follows a four-step mathematical progression:</p>"},{"location":"theory/core-concepts/#1-constraint-formulation","title":"1. Constraint Formulation","text":"<p>First, we mathematically formulate how articulated bodies and their interactions are represented as constraint equations. This establishes the mathematical foundation for describing joints, contacts, and friction.</p> <p>\u2192 Next: Constraints Formulation</p>"},{"location":"theory/core-concepts/#2-optimization-principle","title":"2. Optimization Principle","text":"<p>We apply Gauss's Principle of Least Constraint, which provides a principled way to determine how the system should evolve when subject to constraints. This principle frames constraint enforcement as an optimization problem.</p> <p>\u2192 Next: Gauss's Principle of Least Constraint</p>"},{"location":"theory/core-concepts/#3-nonlinear-system","title":"3. Nonlinear System","text":"<p>The optimization principle, combined with time discretization, leads to a large nonlinear system of equations that must be solved at each time step. This system encodes all physical laws simultaneously.</p> <p>\u2192 Next: Nonlinear System</p>"},{"location":"theory/core-concepts/#4-numerical-solution","title":"4. Numerical Solution","text":"<p>Finally, we numerically solve this nonlinear system using a specialized Newton-type method designed to handle the non-smooth nature of contact and friction.</p> <p>\u2192 Next: Numerical Solution</p>"},{"location":"theory/core-concepts/#why-this-unified-approach","title":"Why This Unified Approach?","text":"<p>Traditional physics engines handle dynamics, contacts, and joints in separate phases, leading to:</p> <ul> <li>Instability in tightly coupled systems</li> <li>Drift and constraint violation accumulation  </li> <li>Artificial softness in joints and contacts</li> </ul> <p>Axion's unified mathematical formulation addresses these issues by:</p> <ul> <li>Solving everything simultaneously \u2014 no artificial sequencing</li> <li>Position-level constraint enforcement \u2014 eliminates drift by design</li> <li>Principled optimization framework \u2014 mathematically grounded decisions</li> </ul> <p>This mathematical rigor enables stable simulation of complex scenarios like articulated robots making contact with the environment, which often challenge traditional approaches.</p>"},{"location":"theory/gauss-least-constraint/","title":"The Guiding Rule: Gauss's Principle of Least Constraint","text":"<p>At the core of Axion's dynamics engine is a beautifully simple and powerful idea from classical mechanics: Gauss's Principle of Least Constraint. This principle provides a single, elegant rule for determining how a system of bodies should move when subjected to constraints (like joints or contacts).</p>"},{"location":"theory/gauss-least-constraint/#the-core-idea-in-simple-terms","title":"The Core Idea in Simple Terms","text":"<p>Imagine a bead sliding along a bent frictionless wire (the constraint). If you flick the bead, it will try to move in a straight line (unconstrained motion). However, the wire forces it to follow a curve. Gauss's Principle states that at every single moment, the wire will exert the absolute minimum force necessary to keep the bead on its path.</p> <p>In essence, a constrained system will always accelerate in a way that is \"as close as possible\" to how it would accelerate if the constraints were not there. This deviation caused by the constraints is what Gauss called the \"constraint\" and stated that the system moves to make this value as small as possible.</p>"},{"location":"theory/gauss-least-constraint/#the-formal-principle","title":"The Formal Principle","text":"<p>Gauss's Principle is formulated as a minimization problem. It states that the true acceleration \\(\\mathbf{a}\\) of a mechanical system is the one that minimizes the following objective function, \\(Z\\):</p> \\[ Z(\\mathbf{a}) = (\\mathbf{a} - \\mathbf{a_\\text{free}})^\\top \\mathbf{\\tilde{M}} (\\mathbf{a} - \\mathbf{a_\\text{free}}) \\quad(1) \\] <p>Where:</p> <ul> <li>\\(\\mathbf{a}\\) is a possible acceleration of the system that is consistent with the constraints.</li> <li>\\(\\mathbf{a_\\text{free}}\\) is the unconstrained acceleration\u2014the acceleration the system would have if only external forces (like gravity) were applied. It is calculated as \\(\\mathbf{a_\\text{free}} = \\mathbf{\\tilde{M}}^{-1} \\mathbf{f_\\text{ext}}\\).</li> <li>\\(\\mathbf{\\tilde{M}}\\) is the system's Generalized Mass Matrix (\\(\\mathbf{\\tilde{M}} = \\mathbf{G}^\\top \\mathbf{M G}\\)). (See Notation)</li> </ul> <p>The principle says: out of all valid accelerations, nature chooses the one that minimizes this mass-weighted squared deviation from the free acceleration.</p>"},{"location":"theory/gauss-least-constraint/#from-principle-to-practice-the-simulators-objective","title":"From Principle to Practice: The Simulator's Objective","text":"<p>To use this principle in a simulator, we must translate it into a concrete optimization problem that we can solve at each discrete time step \\(h\\).</p> <p>1. Rephrasing in Terms of Constraint Forces</p> <p>The difference between the true acceleration and the free acceleration is caused solely by constraint forces (\\(f_c\\)).</p> \\[ \\mathbf{a} - \\mathbf{a_\\text{free}} = (\\mathbf{\\tilde{M}}^{-1}(\\mathbf{f_\\text{ext}} + \\mathbf{f_c})) - (\\mathbf{\\tilde{M}}^{-1}\\mathbf{f_\\text{ext}}) = \\mathbf{\\tilde{M}}^{-1}\\mathbf{f_c} \\] <p>If we substitute this back into the objective function (1), we find something remarkable:</p> \\[ Z \\propto \\mathbf{f_c}^\\top \\mathbf{\\tilde{M}}^{-1} \\mathbf{f_c} \\] <p>This reveals the powerful physical intuition of the principle: Minimizing the objective function \\(Z\\) is equivalent to finding the constraint forces of minimum magnitude. The system doesn't \"work\" any harder than it has to.</p> <p>2. Formulating for the Next Velocity State</p> <p>A solver doesn't work with abstract forces; it solves for the state at the next time step. Our primary unknown is the generalized velocity at the next step, \\(\\mathbf{u}^+\\).</p> <p>Using a simple backward Euler integration scheme, we can approximate the acceleration as:</p> \\[     \\mathbf{a} \\approx \\frac{\\mathbf{u}^+ - \\mathbf{u}^-}{h} \\] <p>By substituting this and similar terms into the objective function and re-arranging, we can rewrite the entire minimization problem in terms of \\(\\mathbf{u}^+\\). This yields the final objective function that Axion solves:</p> \\[ \\min_{\\mathbf{u}^+} \\quad (\\mathbf{u}^+ - \\tilde{\\mathbf{u}})^\\top \\mathbf{\\tilde{M}} (\\mathbf{u}^+ - \\tilde{\\mathbf{u}}) \\quad(2) \\] <p>Where:</p> <ul> <li>\\(\\mathbf{u}^+\\) is the generalized velocity we are solving for. (See Notation)</li> <li>\\(\\tilde{\\mathbf{u}}\\) is the predicted unconstrained velocity: \\(\\tilde{\\mathbf{u}} = \\mathbf{u}^- + h \\mathbf{\\tilde{M}}^{-1} \\mathbf{f_\\text{ext}}\\). This is where the system \"wants\" to go.</li> <li>\\(\\mathbf{\\tilde{M}}\\) is the Generalized Mass Matrix.</li> </ul>"},{"location":"theory/gauss-least-constraint/#solving-with-lagrange-multipliers","title":"Solving with Lagrange Multipliers","text":"<p>The objective function (2) tells us what we want to minimize, but it must be solved subject to the system's constraints. These constraints dictate that the final velocity \\(\\mathbf{u}^+\\) must be physically valid (e.g., no penetration, joints stay connected).</p> <p>For a simplified case with only linear equality constraints (like a perfect hinge joint), we can write these constraints as:</p> \\[ \\mathbf{J} \\mathbf{u}^{+} = \\mathbf{0} \\] <p>where \\(\\mathbf{J}\\) is the constraint Jacobian. The optimization problem is now a classic Constrained Quadratic Program. A standard technique to solve this is the method of Lagrange multipliers. We introduce a vector of Lagrange multipliers, \\(\\boldsymbol{\\lambda}\\), one for each constraint equation. Physically, these multipliers represent the magnitude of the constraint impulses needed to enforce the constraints.</p> <p>Solving this constrained problem yields a coupled system of linear equations for the unknowns \\(\\mathbf{u}^+\\) and \\(\\boldsymbol{\\lambda}\\):</p> \\[ \\begin{align} \\mathbf{\\tilde{M}} \\mathbf{u}^{+} + \\mathbf{J}^\\top \\boldsymbol{\\lambda} &amp;= \\mathbf{\\tilde{M}} \\mathbf{u}^- + h \\mathbf{f_\\text{ext}} \\quad &amp;(3)\\\\ \\mathbf{J} \\mathbf{u}^{+} &amp;= \\mathbf{0} \\quad\\quad\\quad\\quad\\quad\\;\\;\\; &amp;(4) \\end{align} \\] <p>This system is fundamental. Equation (3) is the discretized equation of motion including the constraint impulses (\\(\\mathbf{J}^\\top \\boldsymbol{\\lambda}\\)), and equation (4) is the constraint condition itself. Together, they allow us to solve for the physically correct motion of the system.</p>"},{"location":"theory/gauss-least-constraint/#summary-and-next-steps","title":"Summary and Next Steps","text":"<p>Gauss's Principle of Least Constraint provides a powerful and robust foundation for our simulator. It transforms the complex problem of constrained dynamics into a standard mathematical optimization problem with a known solution: a Constrained Quadratic Program (CQP).</p> <p>Our task is now clear:</p> <p>Minimize the objective function (2) subject to the condition that the final velocity \\(\\mathbf{u}^+\\) satisfies all physical constraint laws (e.g., non-penetration for contacts, velocity matching for joints).</p> <p>The next step is to define these physical constraint laws mathematically. We will do this by formulating them as a set of nonlinear equations that must equal zero.</p> <p>Next: The Complete Nonlinear System</p>"},{"location":"theory/non-linear-system/","title":"The Nonlinear System","text":"<p>This section details how the optimization problem from Gauss's Principle of Least Constraint, combined with the constraint laws from Constraints Formulation, is formally expressed as a large, simultaneous system of nonlinear equations. The goal is to find the root of this system, which represents the physically correct state of all bodies at the next time step.</p> <p>This transformation from a constrained optimization problem to a root-finding problem is achieved by applying the Karush-Kuhn-Tucker (KKT) conditions. The resulting system can be expressed as a single function \\(\\mathbf{h}(\\mathbf{x}^+) = \\mathbf{0}\\), where the unknown vector \\(\\mathbf{x}^+ = [\\mathbf{q}^+, \\mathbf{u}^+, \\boldsymbol{\\lambda}^+]\\) contains the final configurations, velocities, and constraint impulses.</p> <p>The following sections will deconstruct the residual vector \\(\\mathbf{h}\\) piece by piece, explaining the physical meaning and mathematical formulation of each component before assembling them into the final system.</p>"},{"location":"theory/non-linear-system/#residual-functions","title":"Residual Functions","text":""},{"location":"theory/non-linear-system/#dynamics-the-equations-of-motion-mathbfh_textdyn","title":"Dynamics: The Equations of Motion (\\(\\mathbf{h_\\text{dyn}}\\))","text":"<p>This residual represents the core equations of motion, a discrete-time-step version of Newton's second law expressed in generalized coordinates. It stems directly from Gauss's Principle and dictates how constraint impulses alter the system's velocity.</p> <p>The equation is:</p> \\[ \\mathbf{h_\\text{dyn}} = \\mathbf{\\tilde{M}} \\cdot (\\mathbf{u}^+ - \\tilde{\\mathbf{u}}) - \\mathbf{J}_b^T \\boldsymbol{\\lambda}_b^+ - \\mathbf{J}_n^T \\boldsymbol{\\lambda}_n^+ - \\mathbf{J}_f^T \\boldsymbol{\\lambda}_f^+ = \\mathbf{0} \\] <p>Breaking this down:</p> <ul> <li>\\(\\mathbf{\\tilde{M}} \\cdot (\\mathbf{u}^+ - \\tilde{\\mathbf{u}})\\) is the change in the system's generalized momentum caused by constraints. The term \\(\\tilde{\\mathbf{u}} = \\mathbf{u}^- + h \\mathbf{\\tilde{M}}^{-1} \\mathbf{f}_{\\text{ext}}\\) represents the predicted \"unconstrained\" velocity\u2014what the velocity would be if only external forces like gravity were applied.</li> <li>\\(\\mathbf{J}_b^T \\boldsymbol{\\lambda}_b^+ + \\mathbf{J}_n^T \\boldsymbol{\\lambda}_n^+ + \\mathbf{J}_f^T \\boldsymbol{\\lambda}_f^+\\) is the total impulse applied over the time step \\(h\\) by all constraints (bilateral, normal contact, and friction). The Jacobians \\(\\mathbf{J}^T\\) serve to map these impulses from the constraint space back into forces and torques in the generalized coordinate space.</li> </ul> <p>In essence, this equation states: \"The change in momentum from the unconstrained state to the final state must be exactly equal to the total impulse applied by all constraints.\"</p>"},{"location":"theory/non-linear-system/#kinematics-time-integration-mathbfh_textkin","title":"Kinematics: Time Integration (\\(\\mathbf{h_\\text{kin}}\\))","text":"<p>This residual connects the system's final configuration \\(\\mathbf{q}^+\\) to its final velocity \\(\\mathbf{u}^+\\) through a time integration rule. Axion uses an implicit integration scheme for superior stability.</p> <p>The equation is:</p> \\[ \\mathbf{h_\\text{kin}} = \\mathbf{q}^+ - \\mathbf{q}^- - h \\cdot \\mathbf{G}(\\mathbf{q}^+) \\cdot \\mathbf{u}^+ = \\mathbf{0} \\] <p>Here:</p> <ul> <li>This is a Backward Euler integration step. It defines the final position \\(\\mathbf{q}^+\\) based on the final velocity \\(\\mathbf{u}^+\\). Because the quantity we are solving for (\\(\\mathbf{u}^+\\)) is used to compute the final state, the method is implicit. This is crucial for stability in stiff systems, like those with many contacts and joints.</li> <li>The matrix \\(\\mathbf{G}(\\mathbf{q}^+)\\) is the kinematic mapping that transforms generalized velocities (which have \\(n_u\\) dimensions, e.g., 6 for a rigid body) into configuration derivatives (which have \\(n_q\\) dimensions, e.g., 7 for a position +quaternion-based orientation of a  rigid body).</li> </ul> <p>This equation ensures that the final configuration and velocity are mutually consistent according to the laws of motion over the discrete time step \\(h\\).</p>"},{"location":"theory/non-linear-system/#bilateral-constraints-joints","title":"Bilateral Constraints (Joints)","text":"<p>Bilateral constraints enforce an exact geometric relationship (\\(\\mathbf{c}_b(\\mathbf{q}) = \\mathbf{0}\\)). Axion can enforce this at either the position or velocity level.</p> <ul> <li>Position-Level Formulation: This is Axion's preferred method as it completely eliminates numerical drift. The constraint is enforced directly on the final configuration \\(\\mathbf{q}^+\\). A compliance matrix \\(\\boldsymbol{\\Sigma}\\) can be introduced to model \"soft\" joints or improve numerical conditioning. The resulting residual equation is:</li> </ul> \\[ \\mathbf{h_b}^{(\\text{pos})} = \\mathbf{c}_b(\\mathbf{q}^+) + \\boldsymbol{\\Sigma} \\cdot \\boldsymbol{\\lambda}_b^+ = \\mathbf{0} \\] <ul> <li>Velocity-Level Formulation (Alternative): This alternative enforces the constraint on velocities (\\(\\mathbf{J}_b \\cdot \\mathbf{u} = \\mathbf{0}\\)). To counteract the inevitable positional drift from numerical integration, Baumgarte stabilization adds a correction term that pushes the system back toward the valid configuration. The residual equation becomes:</li> </ul> \\[ \\mathbf{h_b}^{(\\text{vel})} = \\mathbf{J}_b \\cdot \\mathbf{u}^+ + \\boldsymbol{\\Upsilon} \\cdot \\frac{\\mathbf{c}_b(\\mathbf{q}^-)}{h} + \\boldsymbol{\\Sigma} \\cdot \\boldsymbol{\\lambda}_b^+ = \\mathbf{0} \\] <p>where the term \\(\\boldsymbol{\\Upsilon} \\cdot \\frac{\\mathbf{c}_b(\\mathbf{q}^-)}{h}\\) introduces a velocity goal that attempts to correct a fraction of the existing position error \\(\\mathbf{c}_b(\\mathbf{q}^-)\\) over the current time step.</p>"},{"location":"theory/non-linear-system/#unilateral-constraints-contacts","title":"Unilateral Constraints (Contacts)","text":"<p>Contact non-penetration (\\(\\mathbf{c_n}(\\mathbf{q}) \\geq 0\\)) is governed by a complementarity condition: a repulsive impulse (\\(\\lambda_n \\geq 0\\)) can only exist upon contact (\\(\\mathbf{c_n}(\\mathbf{q}) = 0\\)).</p> <ul> <li>Position-Level Formulation: The core physical principle is the Nonlinear Complementarity Problem (NCP):</li> </ul> \\[ 0 \\leq \\lambda_n \\perp \\mathbf{c}_{n}(\\mathbf{q}) \\geq 0 \\] <p>To integrate this into a Newton-based solver, we convert this non-smooth condition into a smooth equation using the Fischer-Burmeister NCP-function, \\(\\boldsymbol{\\phi}\\). The residual equation becomes:</p> \\[ \\mathbf{h_n}^{(\\text{pos})} = \\boldsymbol{\\phi}(\\mathbf{c_n}(\\mathbf{q}^+), \\boldsymbol{\\lambda_n}^+) = \\mathbf{c_n}(\\mathbf{q}^+) + \\boldsymbol{\\lambda_n}^+ - \\sqrt{(\\mathbf{c_n}(\\mathbf{q}^+))^2 + (\\boldsymbol{\\lambda}_n^+)^2} = \\mathbf{0} \\] <ul> <li>Velocity-Level Formulation (Alternative): At the velocity level, the complementarity applies to the post-collision relative normal velocity. To model bounce (via restitution \\(e \\in [0, 1] \\)) and combat drift (Baumgarte stabilization), we define a target velocity:</li> </ul> \\[ \\mathbf{v_{n, \\text{target}}}^+ = \\mathbf{J_n} \\cdot (\\mathbf{u}^+ + e \\cdot \\mathbf{u}^- ) + \\boldsymbol{\\Upsilon} \\cdot \\frac{\\mathbf{c_n}(\\mathbf{q}^-)}{h} \\] <p>The complementarity problem is now \\(0 \\leq \\lambda_n \\perp \\mathbf{v_{n, \\text{target}}}^+ \\geq 0\\). Applying the Fischer-Burmeister function gives the final residual:</p> \\[ \\mathbf{h_n}^{(\\text{vel})} = \\boldsymbol{\\phi}(\\mathbf{v_{n, \\text{target}}}^+, \\boldsymbol{\\lambda_n}^+) = \\mathbf{v_{n, \\text{target}}}^+ + \\boldsymbol{\\lambda_n}^+ - \\sqrt{(\\mathbf{v_{n, \\text{target}}}^+)^2 + (\\boldsymbol{\\lambda}_n^+)^2} = \\mathbf{0} \\]"},{"location":"theory/non-linear-system/#friction-constraints","title":"Friction Constraints","text":"<p>Friction resists tangential motion and is formulated at the velocity level using the principle of maximal dissipation, subject to the Coulomb friction law:</p> \\[ \\|\\boldsymbol{\\lambda}_t\\| \\leq \\mu \\cdot \\lambda_n \\] <p>The resulting Karush-Kuhn-Tucker (KKT) conditions mathematically express the stick-slip behavior:</p> <ol> <li>Directional Constraint: The friction impulse must oppose the direction of slip.</li> </ol> \\[ \\mathbf{J}_f^T \\cdot \\mathbf{u} + \\frac{|\\mathbf{J}_f^T \\cdot \\mathbf{u}|}{|\\boldsymbol{\\lambda}_f|} \\cdot \\boldsymbol{\\lambda}_f = \\mathbf{0} \\] <ol> <li>Stick-Slip Switching (Complementarity): Either the bodies are slipping and friction is maximal, or they are sticking and friction is sub-maximal.</li> </ol> \\[ 0 \\leq |\\mathbf{J}_f^T \\cdot \\mathbf{u}| \\perp \\mu \\cdot \\lambda_n - \\|\\boldsymbol{\\lambda}_f\\| \\geq 0 \\] <p>To make this complex system solvable and efficient, Axion employs a two-step transformation. First, the complementarity condition is turned into a root-finding problem with an NCP function, \\(\\phi_f\\). Second, a fixed-point iteration is introduced via a carefully constructed scalar compliance term \\(W\\):</p> \\[ W = \\frac{|\\mathbf{J}_f^T \\cdot \\mathbf{u}| - \\phi_f(|\\mathbf{J}_f^T \\cdot \\mathbf{u}|, \\mu \\cdot \\lambda_n - \\|\\boldsymbol{\\lambda}_f\\|)}{\\|\\boldsymbol{\\lambda}_f\\| + \\phi_f(|\\mathbf{J}_f^T \\cdot \\mathbf{u}|, \\mu \\cdot \\lambda_n - \\|\\boldsymbol{\\lambda_f}\\|)} \\] <p>This allows the entire friction model to be distilled into a single, elegant residual equation that crucially leads to a symmetric system matrix:</p> \\[ \\mathbf{h_f} = \\mathbf{J}_f^T \\cdot \\mathbf{u}^+ + \\mathbf{W} \\cdot \\boldsymbol{\\lambda}_f^+ = \\mathbf{0} \\]"},{"location":"theory/non-linear-system/#the-complete-nonlinear-system","title":"The Complete Nonlinear System","text":"<p>Assembling all the individual residual blocks yields the complete nonlinear system that Axion must solve at every time step.</p> <p>The full residual vector is stacked as follows:</p> \\[ \\mathbf{h}(\\mathbf{x}^+) = \\begin{bmatrix} \\mathbf{h_\\text{dyn}} \\\\ \\mathbf{h_\\text{kin}} \\\\ \\mathbf{h_b} \\\\ \\mathbf{h_n} \\\\ \\mathbf{h_f} \\end{bmatrix} = \\mathbf{0} \\] <p>Explicitly, the full system of equations is:</p> \\[ \\begin{align*} \\text{Dynamics:} \\quad &amp; \\mathbf{\\tilde{M}} \\cdot (\\mathbf{u}^+ - \\tilde{\\mathbf{u}}) - \\mathbf{J}_b^T \\boldsymbol{\\lambda}_b^+ - \\mathbf{J}_n^T \\boldsymbol{\\lambda}_n^+ - \\mathbf{J}_f^T \\boldsymbol{\\lambda}_f^+ = \\mathbf{0} \\\\ \\text{Kinematics:} \\quad &amp; \\mathbf{q}^+ - \\mathbf{q}^- - h \\cdot \\mathbf{G}(\\mathbf{q}^+) \\cdot \\mathbf{u}^+ = \\mathbf{0} \\\\ \\text{Bilateral:} \\quad &amp; \\mathbf{h_b}^{(\\text{pos})} \\quad \\text{or} \\quad \\mathbf{h_b}^{(\\text{vel})} = \\mathbf{0} \\\\ \\text{Contact:} \\quad &amp; \\mathbf{h_n}^{(\\text{pos})} \\quad \\text{or} \\quad \\mathbf{h_n}^{(\\text{vel})} = \\mathbf{0} \\\\ \\text{Friction:} \\quad &amp; \\mathbf{J}_f^T \\cdot \\mathbf{u}^+ + \\mathbf{W} \\cdot \\boldsymbol{\\lambda}_f^+ = \\mathbf{0} \\end{align*} \\] <p>This unified system represents all physical laws acting simultaneously. At each iteration of the numerical solver, all matrices (\\(\\mathbf{J}\\), \\(\\mathbf{G}\\), \\(\\mathbf{W}\\), etc.) are evaluated. The solution to \\(\\mathbf{h}(\\mathbf{x}^+) = \\mathbf{0}\\) is a state vector \\(\\mathbf{x}^+\\) that satisfies dynamics, kinematics, and all physical constraints to a high degree of precision, ready for the next simulation frame.</p> <p>\u2192 Next: Numerical Solution</p>"},{"location":"theory/notation/","title":"Notation and Symbols","text":"<p>This page serves as a central glossary for the mathematical notation used throughout the Axion documentation. It defines the state variables, system parameters, and derivative matrices that form the foundation of the physics engine.</p>"},{"location":"theory/notation/#1-dimension-and-indexing-notation","title":"1. Dimension and Indexing Notation","text":"<p>This table defines the symbols used to represent the size of various vectors and matrices.</p> Symbol Description Comment \\(n_q\\) Configuration Space Dimension The dimension of the generalized coordinate vector \\(\\mathbf{q}\\). \\(n_u\\) Velocity Space Dimension (DOF) The dimension of the generalized velocity vector \\(\\mathbf{u}\\). Equals total degrees of freedom. \\(n_b\\) Number of Bilateral Constraints The number of active bilateral (joint) constraint equations. \\(n_n\\) Number of Unilateral Constraints The number of active unilateral (contact) constraint equations. \\(n_f\\) Number of Frictional Constraints The number of active frictional constraint equations (typically 2 per contact). \\(n_c\\) Total Number of Constraints The sum of all active constraints: \\(n_c = n_b + n_n + n_f\\). <p>Note on \\(n_q\\) vs \\(n_u\\): The relationship between configuration and velocity dimensions depends on the object representation:</p> <p>Rigid Bodies: \\(n_q = 7 \\cdot n_{rb}\\), \\(n_u = 6 \\cdot n_{rb}\\)</p> <ul> <li>Configuration: \\(\\mathbf{q}_i = [\\mathbf{x}_i, \\boldsymbol{\\theta}_i]\\) where \\(\\mathbf{x}_i \\in \\mathbb{R}^3\\) (position), \\(\\boldsymbol{\\theta}_i \\in \\mathbb{R}^4\\) (quaternion)</li> <li>Velocity: \\(\\mathbf{u}_i = [\\mathbf{v}_i, \\boldsymbol{\\omega}_i]\\) where \\(\\mathbf{v}_i \\in \\mathbb{R}^3\\) (linear velocity), \\(\\boldsymbol{\\omega}_i \\in \\mathbb{R}^3\\) (angular velocity)</li> </ul> <p>Particles: \\(n_q = n_u = 3 \\cdot n_{particles}\\)</p> <ul> <li>Configuration/Velocity: \\(\\mathbf{q}_i = \\mathbf{u}_i = \\mathbf{x}_i \\in \\mathbb{R}^3\\) (position/velocity only)</li> </ul> <p>Mixed Systems: \\(n_q\\) and \\(n_u\\) computed based on the specific objects in the system</p>"},{"location":"theory/notation/#2-state-vectors-and-their-components","title":"2. State Vectors and Their Components","text":"<p>These are the primary variables that the solver calculates at each time step. The full state is denoted by \\(\\mathbf{x} = [\\mathbf{q}, \\mathbf{u}, \\boldsymbol{\\lambda}]\\).</p> Symbol Name / Description Dimensions \\(\\mathbf{q}\\) Generalized Configuration \\(\\mathbb{R}^{n_q}\\) \\(\\mathbf{q}_i\\) Configuration of object \\(i\\) Varies by object type (e.g., \\(\\mathbb{R}^7\\) for rigid bodies, \\(\\mathbb{R}^3\\) for particles) \\(\\mathbf{u}\\) Generalized Velocity \\(\\mathbb{R}^{n_u}\\) \\(\\mathbf{u}_i\\) Velocity of object \\(i\\) Varies by object type (e.g., \\(\\mathbb{R}^6\\) for rigid bodies, \\(\\mathbb{R}^3\\) for particles) \\(\\boldsymbol{\\lambda}\\) Constraint Impulses (Lagrange Multipliers) \\(\\mathbb{R}^{n_c}\\) \\(\\boldsymbol{\\lambda}_b\\) Impulses for bilateral constraints (joints) \\(\\mathbb{R}^{n_b}\\) \\(\\boldsymbol{\\lambda}_n\\) Impulses for unilateral constraints (contacts) \\(\\mathbb{R}^{n_n}\\) \\(\\boldsymbol{\\lambda}_f\\) Impulses for frictional constraints \\(\\mathbb{R}^{n_f}\\)"},{"location":"theory/notation/#3-system-matrices-and-parameters","title":"3. System Matrices and Parameters","text":"<p>These matrices and scalar parameters define the physical properties of the system.</p> Symbol Name / Description Dimensions \\(\\mathbf{M}\\) Spatial Mass Matrix \\(\\mathbb{R}^{n_q \\times n_q}\\) \\(\\mathbf{G}(\\mathbf{q})\\) Kinematic Mapping \\(\\mathbb{R}^{n_q \\times n_u}\\) \\(\\mathbf{\\tilde{M}}\\) Generalized Mass Matrix \\(\\mathbb{R}^{n_u \\times n_u}\\) <p>Relationship between \\(\\mathbf{M}\\), \\(\\mathbf{G}\\), and \\(\\mathbf{\\tilde{M}}\\):</p> <ul> <li>\\(\\mathbf{M}\\) is the mass matrix that operates on configuration derivatives (\\(\\dot{\\mathbf{q}}\\)).</li> <li>\\(\\mathbf{G}(\\mathbf{q})\\) is the matrix that maps generalized velocities to configuration derivatives:</li> </ul> \\[ \\dot{\\mathbf{q}} = \\mathbf{G}(\\mathbf{q}) \\cdot \\mathbf{u}. \\] <p>This is necessary to handle the 7D quaternion representation of orientation.</p> <ul> <li>\\(\\mathbf{\\tilde{M}}\\) is the mass matrix in the space of generalized velocities (\\(\\mathbf{u}\\)). It is derived via the kinematic mapping:</li> </ul> \\[ \\mathbf{\\tilde{M}} = \\mathbf{G}(\\mathbf{q})^\\top \\cdot \\mathbf{M} \\cdot \\mathbf{G}(\\mathbf{q}) \\]"},{"location":"theory/notation/#4-constraint-and-residual-functions","title":"4. Constraint and Residual Functions","text":"<p>These functions define the physical laws and constraints that must be satisfied. The solver works by finding the root of the stacked residual vector \\(\\mathbf{h}\\).</p> Symbol Name / Description Dimensions \\(\\mathbf{c}(\\mathbf{q})\\) Position-level Constraint Function \\(\\mathbb{R}^{n_c}\\) \\(\\mathbf{c}_b(\\mathbf{q})\\) Function for bilateral (joint) constraints \\(\\mathbb{R}^{n_b}\\) \\(\\mathbf{c}_n(\\mathbf{q})\\) Function for unilateral (contact) constraints (gap function) \\(\\mathbb{R}^{n_n}\\) \\(\\mathbf{c}_f(\\mathbf{q})\\) Function for friction constraints (tangential distances) \\(\\mathbb{R}^{n_f}\\) \\(\\mathbf{h}(\\mathbf{x})\\) Nonlinear Residual Function (Root Function) \\(\\mathbb{R}^{n_{sys}}\\) \\(\\mathbf{h}_{\\text{dyn}}\\) Residual for the equations of motion (Dynamics) \\(\\mathbb{R}^{n_u}\\) \\(\\mathbf{h}_{\\text{kin}}\\) Residual for the time integration scheme (Kinematics) \\(\\mathbb{R}^{n_q}\\) \\(\\mathbf{h}_b\\) Residual for bilateral constraints \\(\\mathbb{R}^{n_b}\\) \\(\\mathbf{h}_n\\) Residual for contact constraints \\(\\mathbb{R}^{n_n}\\) \\(\\mathbf{h}_f\\) Residual for friction constraints \\(\\mathbb{R}^{n_f}\\) <p>Note: The total system dimension is \\(n_{sys} = n_u + n_q + n_c\\), representing the vector</p> \\[ \\mathbf{h} = \\begin{bmatrix}         \\mathbf{h}_{\\text{dyn}} \\\\         \\mathbf{h}_{\\text{kin}} \\\\         \\mathbf{h}_{\\text{b}} \\\\         \\mathbf{h}_{\\text{n}} \\\\         \\mathbf{h}_{\\text{f}} \\\\     \\end{bmatrix}. \\]"},{"location":"theory/notation/#5-jacobians-and-system-derivatives","title":"5. Jacobians and System Derivatives","text":"<p>Jacobians are matrices of partial derivatives that are essential for linearizing the system. The following table defines the key derivative matrices used in the system.</p> Symbol Name Definition Dimensions \\(\\mathbf{J}\\) Velocity Jacobian \\(\\mathbf{J} = \\frac{\\partial \\mathbf{c}}{\\partial \\mathbf{q}} \\cdot \\mathbf{G}(\\mathbf{q})\\) \\(n_c \\times n_u\\) \\(\\mathbf{J}_b\\) Velocity Jacobian for bilateral constraints \\(\\mathbf{J}_b = \\frac{\\partial \\mathbf{c}_b}{\\partial \\mathbf{q}} \\cdot \\mathbf{G}(\\mathbf{q})\\) \\(n_b \\times n_u\\) \\(\\mathbf{J}_n\\) Velocity Jacobian for contact constraints \\(\\mathbf{J}_n = \\frac{\\partial \\mathbf{c}_n}{\\partial \\mathbf{q}} \\cdot \\mathbf{G}(\\mathbf{q})\\) \\(n_n \\times n_u\\) \\(\\mathbf{J}_f\\) Velocity Jacobian for friction constraints \\(\\mathbf{J}_f = \\frac{\\partial \\mathbf{c}_f}{\\partial \\mathbf{q}} \\cdot \\mathbf{G}(\\mathbf{q})\\) \\(n_f \\times n_u\\) \\(\\hat{\\mathbf{J}}\\) System Jacobian Block \\(\\hat{\\mathbf{J}} = \\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{u}}\\) \\(n_c \\times n_u\\) \\(\\hat{\\mathbf{J}}_b\\) System Jacobian block for bilateral constraints \\(\\hat{\\mathbf{J}}_b = \\frac{\\partial \\mathbf{h}_b}{\\partial \\mathbf{u}}\\) \\(n_b \\times n_u\\) \\(\\hat{\\mathbf{J}}_n\\) System Jacobian block for contact constraints \\(\\hat{\\mathbf{J}}_n = \\frac{\\partial \\mathbf{h}_n}{\\partial \\mathbf{u}}\\) \\(n_n \\times n_u\\) \\(\\hat{\\mathbf{J}}_f\\) System Jacobian block for friction constraints \\(\\hat{\\mathbf{J}}_f = \\frac{\\partial \\mathbf{h}_f}{\\partial \\mathbf{u}}\\) \\(n_f \\times n_u\\) \\(\\mathbf{C}\\) Compliance Block \\(\\mathbf{C} = \\frac{\\partial \\mathbf{h}_c}{\\partial \\boldsymbol{\\lambda}}\\) \\(n_c \\times n_c\\) \\(\\mathbf{C}_b\\) Compliance block for bilateral constraints \\(\\mathbf{C}_b = \\frac{\\partial \\mathbf{h}_b}{\\partial \\boldsymbol{\\lambda}_b}\\) \\(n_b \\times n_b\\) \\(\\mathbf{C}_n\\) Compliance block for contact constraints \\(\\mathbf{C}_n = \\frac{\\partial \\mathbf{h}_n}{\\partial \\boldsymbol{\\lambda}_n}\\) \\(n_n \\times n_n\\) \\(\\mathbf{C}_f\\) Compliance block for friction constraints \\(\\mathbf{C}_f = \\frac{\\partial \\mathbf{h}_f}{\\partial \\boldsymbol{\\lambda}_f}\\) \\(n_f \\times n_f\\)"},{"location":"theory/notation/#velocity-jacobians-mathbfj","title":"Velocity Jacobians (\\(\\mathbf{J}\\))","text":"<p>The velocity Jacobians map generalized velocities \\(\\mathbf{u}\\) directly to constraint derivatives. They are formed by composing the geometric constraint Jacobian with the kinematic mapping:</p> \\[ \\dot{\\mathbf{c}} = \\mathbf{J} \\cdot \\mathbf{u} \\] <p>Constraint-specific Jacobians:</p> <ul> <li>\\(\\mathbf{J}_b\\): Maps body velocities to bilateral constraint violation rates (joint separation velocities)</li> <li>\\(\\mathbf{J}_n\\): Maps body velocities to contact constraint violation rates (normal approach velocities)</li> <li>\\(\\mathbf{J}_f\\): Maps body velocities to friction constraint violation rates (tangential slip velocities)</li> </ul> <p>The full velocity Jacobian is:</p> \\[ \\mathbf{J} = \\begin{bmatrix}         \\mathbf{J}_{\\text{b}} \\\\         \\mathbf{J}_{\\text{n}} \\\\         \\mathbf{J}_{\\text{f}} \\\\     \\end{bmatrix}. \\]"},{"location":"theory/notation/#system-jacobian-blocks-hatmathbfj","title":"System Jacobian Blocks (\\(\\hat{\\mathbf{J}}\\))","text":"<p>The system Jacobian blocks are the actual matrices that appear in the linearized system solved by Newton's method. They represent \\(\\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{u}}\\) for each constraint type.</p> <p>Key differences from velocity Jacobians:</p> <ul> <li>For Bilateral Constraints: (identical to velocity Jacobian)</li> </ul> \\[ \\hat{\\mathbf{J}}_b = \\mathbf{J}_b \\] <ul> <li>For Contact Constraints:</li> </ul> \\[ \\hat{\\mathbf{J}}_n = s_n \\cdot \\mathbf{J}_n \\] <ul> <li>For Friction Constraints: (identical, by design for symmetry)</li> </ul> \\[ \\hat{\\mathbf{J}}_f = \\mathbf{J}_f \\] <p>The \\(s_n\\) is a state-dependent scaling factor from the Fischer-Burmeister NCP-function derivative. The scaling factor \\(s_n\\) for contacts arises because the contact residual \\(\\mathbf{h}_n\\) is nonlinear in the velocities due to the NCP-function formulation.</p>"},{"location":"theory/notation/#compliance-blocks-mathbfc","title":"Compliance Blocks (\\(\\mathbf{C}\\))","text":"<p>Compliance blocks represent the derivative of constraint residuals with respect to constraint impulses: \\(\\mathbf{C} = \\frac{\\partial \\mathbf{h}_c}{\\partial \\boldsymbol{\\lambda}}\\). They appear on the diagonal of the constraint portion of the system matrix and control the \"softness\" of constraints.</p> <p>Bilateral Compliance \\(\\mathbf{C}_b\\): This is the physical compliance matrix \\(\\boldsymbol{\\Sigma}\\) from Baumgarte stabilization. It allows modeling of soft joints or provides numerical stabilization for rigid constraints. For perfectly rigid constraints, this matrix is zero. When non-zero, it represents the inverse stiffness of the joint, enabling compliant behavior. The matrix has dimensions \\(n_b \\times n_b\\) and is typically diagonal, with each diagonal entry corresponding to the compliance of a specific bilateral constraint.</p> <p>Contact Compliance \\(\\mathbf{C}_n\\): This represents numerical compliance arising from the Fischer-Burmeister NCP-function formulation. Unlike bilateral compliance, this is not a physical property but rather a mathematical artifact of the complementarity problem transformation. The matrix is diagonal with dimensions \\(n_n \\times n_n\\), where each entry is computed as \\(c_n = \\frac{\\partial \\phi_n}{\\partial \\lambda_n}\\). These values are state-dependent and vary during Newton iterations as the contact conditions evolve.</p> <p>Friction Compliance \\(\\mathbf{C}_f\\): This is the fixed-point iteration matrix \\(\\mathbf{W}\\) used to create a symmetric system for efficient solving. The matrix is diagonal with dimensions \\(n_f \\times n_f\\) and is updated at each Newton iteration. It is carefully designed so that when the Newton method converges, the exact Coulomb friction conditions are satisfied. This formulation enables the use of symmetric solvers like Preconditioned Conjugate Residual (PCR) for computational efficiency.</p> <p>The complete compliance block assembles these individual blocks in a block-diagonal structure: \\(\\mathbf{C} = \\text{diag}(\\mathbf{C}_b, \\mathbf{C}_n, \\mathbf{C}_f)\\).</p>"},{"location":"theory/numerical-solution/","title":"Numerical Solution","text":"<p>The previous section established a large, non-smooth system of nonlinear equations, \\(\\mathbf{h}(\\mathbf{x}) = \\mathbf{0}\\), that captures the complete physics of the simulation at each time step. This system cannot be solved analytically and requires a powerful iterative approach. This section describes the numerical strategy Axion uses to find the solution.</p> <p>Axion employs an inexact non-smooth Newton-type method. The core idea is to start with a guess for the solution \\(\\mathbf{x}\\) and iteratively refine it. In each iteration \\(k\\), we linearize the nonlinear function \\(\\mathbf{h}(\\mathbf{x})\\) at the current guess \\(\\mathbf{x_k}\\) and solve the resulting linear system for a step \\(\\Delta \\mathbf{x}\\).</p> <p>The linear system to be solved at each iteration is:</p> \\[ \\mathbf{A}(\\mathbf{x_k}) \\Delta \\mathbf{x} = -\\mathbf{h}(\\mathbf{x_k}) \\] <p>where \\(\\mathbf{A} = \\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{x}}\\) is the System Jacobian.</p>"},{"location":"theory/numerical-solution/#linearizing-the-system-and-eliminating-q","title":"Linearizing the System and Eliminating \u0394q","text":"<p>The state vector we are solving for is \\(\\mathbf{x} = [\\mathbf{q}, \\mathbf{u}, \\boldsymbol{\\lambda}]\\), and the corresponding update step is \\(\\Delta\\mathbf{x} = [\\Delta\\mathbf{q}, \\Delta\\mathbf{u}, \\Delta\\boldsymbol{\\lambda}]\\). The full Jacobian \\(\\mathbf{A}\\) is a 3x3 block matrix of partial derivatives. However, we can simplify this system dramatically before solving.</p> <p>The key lies in the linearization of the kinematic equation, \\(\\mathbf{h_\\text{kin}} = \\mathbf{q}^+ - \\mathbf{q}^- - h \\cdot \\mathbf{G}(\\mathbf{q}^+) \\cdot \\mathbf{u}^+ = \\mathbf{0}\\). Taking its derivative gives us a direct relationship between the update steps \\(\\Delta\\mathbf{q}\\) and \\(\\Delta\\mathbf{u}\\). With some simplification (treating \\(\\mathbf{G}\\) as constant for the linearization), we get:</p> \\[ \\Delta\\mathbf{q} - h\\mathbf{G}\\Delta\\mathbf{u} = \\mathbf{0} \\quad \\implies \\quad \\Delta\\mathbf{q} = h\\mathbf{G}\\Delta\\mathbf{u} \\] <p>This powerful relationship tells us that the change in configuration is determined by the change in velocity. We can now use this to eliminate \\(\\Delta\\mathbf{q}\\) from the entire system for the purpose of solving the problem.</p> <p>Consider the linearization of a general constraint residual \\(\\mathbf{h_c}\\), which depends on \\(\\mathbf{q}\\), \\(\\mathbf{u}\\), and \\(\\boldsymbol{\\lambda}\\):</p> \\[ \\frac{\\partial \\mathbf{h_c}}{\\partial \\mathbf{q}}\\Delta\\mathbf{q} + \\frac{\\partial \\mathbf{h_c}}{\\partial \\mathbf{u}}\\Delta\\mathbf{u} + \\frac{\\partial \\mathbf{h_c}}{\\partial \\boldsymbol{\\lambda}}\\Delta\\boldsymbol{\\lambda} = -\\mathbf{h_c} \\] <p>Now, we substitute \\(\\Delta\\mathbf{q} = h\\mathbf{G}\\Delta\\mathbf{u}\\):</p> \\[ \\frac{\\partial \\mathbf{h_c}}{\\partial \\mathbf{q}}(h\\mathbf{G}\\Delta\\mathbf{u}) + \\frac{\\partial \\mathbf{h_c}}{\\partial \\mathbf{u}}\\Delta\\mathbf{u} + \\frac{\\partial \\mathbf{h_c}}{\\partial \\boldsymbol{\\lambda}}\\Delta\\boldsymbol{\\lambda} = -\\mathbf{h_c} \\] <p>Grouping the \\(\\Delta\\mathbf{u}\\) terms gives:</p> \\[ \\left( h \\frac{\\partial \\mathbf{h_c}}{\\partial \\mathbf{q}}\\mathbf{G} + \\frac{\\partial \\mathbf{h_c}}{\\partial \\mathbf{u}} \\right) \\Delta\\mathbf{u} + \\frac{\\partial \\mathbf{h_c}}{\\partial \\boldsymbol{\\lambda}} \\Delta\\boldsymbol{\\lambda} = -\\mathbf{h_c} \\] <p>This defines the matrices for our reduced system. The term in parenthesis is precisely the System Jacobian (\\(\\hat{\\mathbf{J}}\\)), and the multiplier of \\(\\Delta\\boldsymbol{\\lambda}\\) is the Compliance Matrix (\\(\\mathbf{C}\\)).</p> <p>By applying this substitution to the whole system, we eliminate \\(\\Delta\\mathbf{q}\\) entirely, arriving at the final 2x2 block KKT system that is actually solved in practice:</p> \\[     \\begin{bmatrix}         \\mathbf{\\tilde{M}} &amp; -\\hat{\\mathbf{J}}^\\top \\\\         \\hat{\\mathbf{J}} &amp; \\mathbf{C}     \\end{bmatrix}     \\begin{bmatrix}         \\Delta\\mathbf{u} \\\\         \\Delta\\boldsymbol{\\lambda} \\\\     \\end{bmatrix}     =     -\\begin{bmatrix}         \\mathbf{h_\\text{dyn}} \\\\         \\mathbf{h_c}     \\end{bmatrix} \\]"},{"location":"theory/numerical-solution/#schur-complement-a-strategy-for-efficiency","title":"Schur Complement: A Strategy for Efficiency","text":"<p>Solving the full KKT system directly is still inefficient. The matrix is large, sparse, and indefinite. Axion employs the Schur complement method to create an even smaller, better-behaved system to solve. The strategy is to algebraically eliminate the velocity update \\(\\Delta \\mathbf{u}\\) and form a system that solves only for the constraint impulse update \\(\\Delta \\boldsymbol{\\lambda}\\).</p> <p>From the first block row of the KKT system, we express \\(\\Delta\\mathbf{u}\\) in terms of \\(\\Delta\\boldsymbol{\\lambda}\\):</p> \\[ \\Delta\\mathbf{u} = \\mathbf{\\tilde{M}}^{-1} (\\hat{\\mathbf{J}}^\\top \\Delta\\boldsymbol{\\lambda} - \\mathbf{h_\\text{dyn}}) \\] <p>Substituting this into the second block row gives the Schur complement system:</p> \\[     \\left[\\hat{\\mathbf{J}} \\mathbf{\\tilde{M}}^{-1} \\hat{\\mathbf{J}}^\\top + \\mathbf{C} \\right] \\Delta\\boldsymbol{\\lambda} =     \\hat{\\mathbf{J}} \\mathbf{\\tilde{M}}^{-1} \\mathbf{h_\\text{dyn}} - \\mathbf{h_c} \\] <p>This system is smaller, symmetric positive-semidefinite, and amenable to massive parallelism, making it ideal for a Conjugate Residual (CR) iterative solver.</p>"},{"location":"theory/numerical-solution/#the-complete-newton-iteration-a-step-by-step-guide","title":"The Complete Newton Iteration: A Step-by-Step Guide","text":"<p>With this theoretical foundation, we can now outline the exact sequence of computations performed within a single Newton step. This process computes the full update vector \\(\\Delta\\mathbf{x} = [\\Delta\\mathbf{q}, \\Delta\\mathbf{u}, \\Delta\\boldsymbol{\\lambda}]\\) and applies it to the current state estimate \\(\\mathbf{x_k} = [\\mathbf{q_k}, \\mathbf{u_k}, \\boldsymbol{\\lambda_k}]\\).</p> <p>Step 1: Assemble System Components At the current state \\(\\mathbf{x_k}\\), the solver evaluates all required terms: the residual vectors (\\(\\mathbf{h_\\text{dyn}}, \\mathbf{h_c}\\)) and the system matrices (\\(\\hat{\\mathbf{J}}, \\mathbf{C}, \\mathbf{\\tilde{M}}\\)).</p> <p>Step 2: Solve for Impulse Update (\\(\\Delta\\boldsymbol{\\lambda}\\)) This is the core of the computation. The Schur complement system is formed and solved for the first part of our update vector, \\(\\Delta\\boldsymbol{\\lambda}\\). This is done using a Preconditioned Conjugate Residual solver with a Jacobi Preconditioner.</p> <p>Step 3: Back-substitute for Velocity Update (\\(\\Delta\\mathbf{u}\\)) With \\(\\Delta\\boldsymbol{\\lambda}\\) known, the velocity update component, \\(\\Delta\\mathbf{u}\\), is calculated directly using the back-substitution formula derived from the first row of the KKT matrix:</p> \\[ \\Delta\\mathbf{u} = \\mathbf{\\tilde{M}}^{-1} \\left( \\hat{\\mathbf{J}}^\\top \\Delta\\boldsymbol{\\lambda} - \\mathbf{h_\\text{dyn}} \\right) \\] <p>Step 4: Recover the Full Update Vector (\\(\\Delta\\mathbf{x}\\)) Now we recover the final missing piece of the update vector, \\(\\Delta\\mathbf{q}\\), using the same linearized kinematic relationship that we used for the elimination:</p> \\[ \\Delta\\mathbf{q} = h \\cdot \\mathbf{G}(\\mathbf{q_k}) \\cdot \\Delta\\mathbf{u} \\] <p>With all three components computed, we assemble the full Newton step vector:</p> \\[ \\Delta\\mathbf{x} = \\begin{bmatrix} \\Delta\\mathbf{q} \\\\ \\Delta\\mathbf{u} \\\\ \\Delta\\boldsymbol{\\lambda} \\end{bmatrix} \\] <p>This vector represents the complete, linearized search direction for the entire system state.</p> <p>Step 5: Perform Line Search To ensure robust convergence, a line search is performed. This process seeks an optimal step size \\(\\alpha \\in (0, 1]\\) by testing trial states of the form \\(\\mathbf{x_\\text{trial}} = \\mathbf{x_k} + \\alpha \\Delta\\mathbf{x}\\). The goal is to find an \\(\\alpha\\) that guarantees a sufficient decrease in the overall system error, measured by the norm of the full residual vector, \\(\\|\\mathbf{h}(\\mathbf{x_\\text{trial}})\\|\\).</p> <p>Step 6: Update the Full State Vector Finally, the entire state vector is updated in a single, unified operation using the computed full step \\(\\Delta\\mathbf{x}\\) and the optimal step size \\(\\alpha\\) from the line search:</p> \\[ \\mathbf{x_{k+1}} = \\mathbf{x_k} + \\alpha\\Delta\\mathbf{x} \\] <p>This single vector update is equivalent to updating each component individually:</p> \\[ \\begin{align} \\mathbf{q_{k+1}} &amp;= \\mathbf{q_k} + \\alpha \\Delta\\mathbf{q} \\\\ \\mathbf{u_{k+1}} &amp;= \\mathbf{u_k} + \\alpha \\Delta\\mathbf{u} \\\\ \\boldsymbol{\\lambda_{k+1}} &amp;= \\boldsymbol{\\lambda_k} + \\alpha \\Delta\\boldsymbol{\\lambda} \\end{align} \\] <p>This brings us to the end of one Newton iteration. The process repeats from Step 1 with the new state \\(\\mathbf{x_{k+1}}\\) until the norm of the residual vector \\(\\|\\mathbf{h}(\\mathbf{x_{k+1}})\\|\\) falls below a specified tolerance, indicating that a valid physical state has been found.</p>"}]}